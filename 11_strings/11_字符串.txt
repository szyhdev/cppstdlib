第十一章 字符串

一、动机
  1、示例一：引出一个临时文件名
  2、示例二：引出一段文字并逆向打印
二、string的细节描述
  1、string的各种相关类型
    1）头文件
    2）模板类basic_string
    3）string和wstring
  2、操作函数总览
    1）字符串操作函数的参数
    2）未提供的操作函数
  3、构造函数和析构函数
  4、string和C-string
  5、大小和容量
  6、元素存取
  7、比较
  8、更改内容
    1）赋值
    2）交换
    3）使string为空
    4）插入和移除字符
  9、子串和字符串结合
  10、I/O操作符
  11、查找
  12、数值npos的意义
  13、string对迭代器的支持
    1）与迭代器相关的函数
    2）运用实例
  14、国际化
  15、效率
  16、string和vector
三、详述string
  1、内部的类型定义和静态变量
  2、生成、复制和销毁
  3、大小和容量
  4、比较
  5、字符存取
  6、产生C-string和字符数组
  7、更改内容
    1）赋值
    2）添加字符
    3）插入字符
    4）擦除字符
    5）改变大小
    6）替换字符
  8、查找
    1）查找单一字符
    2）查找子字符串
    3）查找第一个匹配的字符
    4）查找最后一个匹配的字符
  9、子字符串及字符串的连接
  10、I/O函数
  11、产生迭代器
  12、对配置器的支持

- 本章讲述C++标准程序库中的字符串类型，包括基本的模板类basic_string和特化类型string和wstring
- 字符串可以是一个char*，可以是一个字符数组，也可以是一个string的实例，或者泛指代表字符串的某个对象
  * 本章中的“字符串”是指某个string或者wstring的对象
  * 对于一般的字符串，比如char*或const char*，则称为“C-string”
- 字符串字面常数会被转换为const char*
- 同时，const char*可以被隐式转换为char*，尽管这种转换并不值得赞赏

一、动机

- C++标准程序库对string的设计思路是，让它的行为尽量像基本类型一样，在操作上不会引起什么麻烦
- 现今世界的大部分数据处理是字符串处理，对于C、Fortran等类似语言的程序员来说，这是个非常重要的进步，因为在那些语言中，字符串处理是一件令人烦恼的事

1、示例一：引出一个临时文件名

- 示例程序通过命令行参数产生一个临时文件名，如果原来的文件名没有扩展名或者扩展名不是tmp，就把它的扩展名设为tmp，否则，就把它的扩展名设为xxx
  * 首先声明四个string变量，filename、basename、extname、tmpname，它们通过默认构造函数被初始化为空字符串
  * 通过拷贝构造函数的一个C-string参数“tmp”对suffix进行初始化
  * 每当for循环执行一次，filename通过赋值操作被依次设置为命令行的第n个参数
  * filename通过成员函数find来查找文件的基本名和扩展名之间的分隔符‘.’，注意，它返回的是一个size_type类型（通常是一个整数）而不是一个迭代器，所以说，字符串并不依赖于STL的概念
  * 如果没有找到‘.’，它返回的是一个特殊值string::npos，于是，通过操作符+，可以将文件的基本名与扩展名连接起来
  * 如果找到了，通过成员函数substr对filename进行分割，分别得到文件的基本名和扩展名
  - 接着，通过成员函数empty检查扩展名是否为空字符串，如果是，就将其扩展名设置为tmp，否则，通过操作符==检查扩展名是否已经是tmp，如果是，就把它修改为xxx，否则，就将其扩展名设置为tmp，这里的成员函数size返回字符串的长度

- 凡是以索引或者长度作为参数的地方，字符串都遵循以下两个规则
  * 索引必须合法，即，它必须大于等于0且小于字符串的长度，否则会引发out_of_range异常，不过，用来查找单一字符或者某个索引的所有查找函数都可以接受任意的索引，如果索引不合法，这些函数会返回string::npos来表示没有找到
  * 长度可以是任意值，如果该值大于实际剩余的字符数，则剩余的字符都会用到，或者如果使用string::npos，则相当于指明要使用剩余的所有字符

2、示例二：引出一段文字并逆向打印

- 示例程序从标准输入读取一个个单词，然后把每个单词逆序打印出来，单词之间一般通过空格符（包括换行符、空格、Tab）、逗号、句号、分号来分隔
  * 所有的分隔符被定义在一个字符串常量delims中
  * 外层循环不断地通过getline函数读取新行到字符串line中，默认情况下使用换行符来换行，如果需要，可以通过为该函数传递第三个参数来设置自己需要的换行符
  * find_first_not_of函数返回不属于指定字符串中字符的第一个字符的索引begIdx，如果没有找到，则返回string::npos
  * 内层循环通过find_first_of函数查找属于指定字符串中字符的第一个字符的索引，查找的起点被设置为begIdx，如果没找到，就通过length成员函数将endIdx设为字符串的终点，否则，从endIdx到begIdx向前逆序打印出该单词的所有字符
  * 注意，operator []不会检查索引的合法性，比较安全的做法是使用成员函数at来存取字符，但会带来效率上的负担
  * 还有一个需要注意的问题是，如果没有把begIdx转换为int，将会陷入无限循环中，因为有符号的i在与无符号的begIdx进行比较时，会被转换为无符号类型，当begIdx位于字符串的开头时，它的值为0，循环判断式永远成立，程序将在访问到某个非法地址时崩溃

二、string的细节描述

1、string的各种相关类型

1）头文件

- 头文件<string>定义了所有的字符串类型和函数，它们都位于名字空间std中

2）模板类basic_string

- basic_string被定义为所有字符串类型的基本模板类
  * 第一个参数指明了单个字符的类型
  * 第二个参数是个特性类型，提供字符串类型中所有的字符核心操作，默认值为char_traits
  * 第三个参数定义了字符串类型采用的内存模式，默认值为allocator

3）string和wstring

- C++标准程序库提供了basic_string的两个特化版本，string和wstring
  * string是针对char的特化版本，适用于一般字符
  * wstring是针对wchar_t的特化版本，适用于宽字符集，比如，Unicode、某些亚洲字符集等
- 二者采用相同的接口，所以，用法和问题都一样，以下的描述大多采用string，但也适用于wstring

2、操作函数总览

- 字符串的操作函数包括构造函数、析构函数、=、assign、swap、+=、append、push_back、insert、erase、clear、resize、replace、+、==/!=/</<=/>/>=、compare、size、length、max_size、empty、capacity、reserve、[]、at、>>/<<、getline、copy、c_str、data、substr、查找函数、begin/end、rbegin/rend、get_allocator

1）字符串操作函数的参数

- STL提供了许多字符串操作函数，其中很多具有多个重载版本，通过一个、两个或三个参数来指定新值
- 只有在单参数版本中的char*才会将‘\0’视为字符串的结尾符号，其他情况下‘\0’都不被视为特殊字符，因此，一般来说字符串中可以包含任意字符，甚至是二进制文件中的内容
- 所有的操作符都只能把对象作为单一值来处理，因此，如果需要赋值、比较或连接字符串的一部分，就必须通过相应的函数来完成

2）未提供的操作函数

- C++标准程序库的string并没有解决所有可能遇到的字符问题
- 事实上，下列问题都没有提供解决之道
  * 正则表达式
  * 文本处理，包括大小写转换、忽略大小写的比较等
- 不过，文本处理方面的问题不大，可以通过string支持的迭代器来解决

3、构造函数和析构函数

- 构造函数和析构函数包括string、以string为参数的string、以string、索引为参数的string、以string、索引、长度为参数的string、以C-string为参数的string、以C-string、长度为参数的string、以数目、字符为参数的string、以区间为参数的string、~string
  * 虽然不能通过单一的字符来初始化字符串，但可以利用构造函数string(num, c)来完成
  * 可以看出，存在从const char*到string的类型转换，但不存在从char到string的类型转换

4、string和C-string

- C++标准将字符串字面常量的类型从char*改为const char*
- 为了提供向下的兼容性，C++标准还规定了一个颇有争议的从const char*到char*的隐式转换
- 由于字符串字面常量并非string类型，因此，新的string类型和传统的C-string之间必然存在一种强烈的关系，比如，二者之间的比较、连接、追加等

- 为了防止出现意外的类型转换导致的怪异行为和模棱两可，存在一个从const char*到string的隐式类型转换，但不存在从string到cosnt char*的隐式转换
- 要把string转换为C-string，可以使用c_str、copy等成员函数
- 注意，‘\0’在C-string中被用作字符串的结束符，但在string中并不具有特殊的意义
- 另外，千万不要使用NULL来取代char*作为参数，因为NULL是个整数类型，这会导致它在单整数类型的重载函数版本中被误认为是数字0

- 三个可以将string转换为字符数组或C-string的函数
  * data：以字符数组的形式返回字符串的内容，不包括字符串结束符‘\0’
  * c_str：以C-string的形式返回字符串的内容，包括字符串结束符‘\0’
  * copy：将字符串的指定内容复制到指定的字符数组中，不会专门添加字符串结束符‘\0’
- 注意，data和c_str返回的字符数组由该字符串拥有，千万不要修改它，同时注意，它的有效期在下一次调用非常量成员函数时就终止了
- 一般来说，整个程序中都应该使用string，直到必须将其转换为C-string时为止

5、大小和容量

- 一个string存在三种关于“大小”的概念
  * size和length：返回一个string中现有字符的数目
  * max_size：返回一个string最多能够包含的字符数目，由于一个string通常包含一个单独内存区块中的所有字符，所以这个值的大小和PC机器本身的限制有关系，一般来说，这个值等于索引类型的最大值减一
  * capacity：在重新分配内存之前，一个string能包含的最大字符数目

- 让string具有足够的容量很重要
  * 重新分配内存会导致指向string的引用、指针和迭代器都失效
  * 重新分配内存很耗费时间
- 成员函数reserve用来为string预留一定的容量，避免重新分配内存的行为

- 容量的概念对于string和vector是相同的，但string的reserve可以缩减实际容量，而vector的reserve则做不到
- 同时，如果参数小于现有字符的数目，reserve实际上是一种非强制性的缩减请求，容量是否真的会缩减取决于string的具体实现，因为对于如何处理速度和内存用量之间的关系，不同的实现者可能会有不同的思路
- 当然，即使发生字符被删除或者改变的事情，对于位于被操作字符前面的字符，它们的引用、指针和迭代器仍然保持有效

6、元素存取

- string提供了两种方法来存取字符，operator []和at
  * operator []并不检查索引是否有效，如果索引无效，会导致未定义的行为，而成员函数at会检查，如果索引无效，会抛出out_of_range异常
  * 对于operator []的常量版本，最后一个字符后面的索引也是有效的，对于string来说，它会返回‘\0’，而对于operator []的非常量版本和at，最后一个字符后面的索引是无效的
- operator []的非常量版本和at都返回字符的引用，一旦重新分配内存，这些引用就会失效，为了避免这种情况，可以通过reserve预留足够的容量

- 以下操作可能导致指向字符的引用或指针失效
  * 使用swap交换两个字符串
  * 使用operator >>或者getline读入新值
  * 通过data或c_str输出内容
  * 调用operator []、at、begin、rbegin、end、rend之外的任何非常量成员函数
  * 调用任何函数并在其后跟着operator []、at、begin、end、rbegin、rend
- 以上描述同样适用于迭代器

7、比较

- string支持常见的比较操作，操作数可以是string或C-string
- 成员函数compare针对一个string可以使用多个参数进行处理，这样就可以通过索引和长度定位到子字符串
- 如果需要不同的比较规则，还可以自己定义，并采用STL的比较算法，或者利用字符特性来完成忽略大小写的比较操作
- 针对国际市场的程序，可能需要按照特殊的当地规则来比较字符串，为此，类locale提供了圆括号操作符

8、更改内容

1）赋值

- operator =用来为字符串赋值，新值可以是string、C-string或单一字符
- 如果需要多个参数来描述新值，可以使用成员函数assign

2）交换

- string提供了一个特殊的swap成员函数来交换两个字符串的内容，它具有常数复杂度，因此，如果赋值之后不再需要旧值，应该利用该函数来进行交换以达到赋新值的目的

3）使string为空

- 许多操作可以使string为空，比如，operator =、clear、erase等

4）插入和移除字符

- operator +=通过单一参数在尾部进行添加字符
- append可以通过多个参数指定添加的字符，还可以将区间添加到尾部
- push_back是为了支持Back插入型迭代器以便在尾部添加字符

- insert用来在指定的索引插入字符，新字符将被插入在该索引之后
  * insert不接受索引和字符的参数组合
  * insert可以接受索引、数目、字符的参数组合，也可以接受迭代器、数目、字符的参数组合，索引的类型是size_type，而迭代器的类型一般是char*，所以，为它们提供0作为参数将导致模棱两可的情况，正确的做法是将0强制转换为size_type
  * 使用迭代器来指定位置可以有三种方式，插入一个字符、插入多个相同的字符、插入通过两个迭代器指定的区间中的字符

- erase用来擦除字符，存在多个重载版本
- replace用来替换字符，也存在多个重载版本
- resize用来改变string的字符数目，如果参数比现有的字符数目少，尾部字符会被移除，否则，会用指定的字符填充尾部

9、子串和字符串结合

- substr用来从string中提取子字符串
- operator +则用来将两个string或C-string连接起来

10、I/O操作符

- operator >>从输入流读取一个string
- operator <<把一个string写入输出流

- operator >>的执行方式
  * 如果设置了skipws标志，则跳过开头的空格
  * 持续地读取所有字符，直到下一个字符为空格符、流不再处于正常状态（比如，到达文件结尾）、流的width大于0并且已经读出width个字符、已经读取max_size个字符等
  * 流的width被设置为0
- 一般来说，operator >>读入下一个字符时，会跳过前导的空格符，所谓空格符是指能够使isspace返回true的字符

- operator <<通常会考虑流的width，如果width大于0，则至少会写入width个字符
- getline是一个用来逐行读取的函数，它会逐行读取所有的字符，包括前导的空格符，直到遇到换行符或者文件的结尾
- 缺省情况下，换行符为‘\n’，也可以通过参数指定自定义的换行符

11、查找

- string提供了很多用于查找字符或子字符串的函数
- 通过这些函数，程序员可以查找单一字符、字符区间或若干字符中的一个，可以前向查找或后向查找，也可以从字符串头部或内部任何地方开始查找
- 另外，如果配上迭代器，STL的所有查找算法都可以应用于string

- 查找的函数包括find、rfind、find_first_of、find_last_of、find_first_not_of、find_last_not_of
  * 所有的查找函数的名字中都有"find"
  * 所有的查找函数都返回符合查找条件的第一个字符的索引，如果没找到，则返回string::npos
- 所有的查找函数都采用下面的参数方案
  * 第一个参数是被查找的对象
  * 第二个参数是查找的起点，该参数是可选的
  * 第三个参数是查找的字符数目，该参数也是可选的
- 所有的查找函数都下面的重载版本
  * 以string为参数
  * 以string、索引为参数
  * 以C-string为参数
  * 以C-string、索引为参数
  * 以C-string、索引、长度为参数
  * 以字符为参数
  * 以字符、索引为参数

- 通过STL的算法也可以查找string中的字符或子字符串，这些算法通常都允许指定自己的比较规则
- 注意，它们的命名方式和string的查找函数的命名方式并不相同

12、数值npos的意义

- 如果查找函数失败，会返回string::npos
- 使用string::npos时要格外小心，检查返回值时一定要使用string::size_type类型，而不能使用int或unsigned int类型，否则返回值与string::npos进行比较时可能无法正确执行
  * 避免这种错误的一种方法是，直接检查查找函数是否失败
  * 另一种方法是，自己定义对应于npos的带正负号的值来进行比较，但这有时也会发生错误
- 所以，如果希望自己的代码具有高度的可移植性，就应该为string的索引使用string::size_type类型

13、string对迭代器的支持

- string是字符的有序集合，因此，C++标准程序库为它提供了相应的接口，以便将string作为容器使用
- 更确切地说，可以通过成员函数获得能够遍历string内部所有字符的迭代器

- string的迭代器是随机存取迭代器，所以，任何一个STL算法都可以与它搭配
- string的迭代器通常被简单地定义为一般指针，当然，这取决于具体的实现版本
- 如果发生内存重分配，或者它指向的值发生了某些变化，迭代器就会失效

1）与迭代器相关的函数

- 与迭代器相关的函数包括begin/end、rbegin/rend、以区间为参数的构造函数、append、assign、以迭代器、字符为参数的insert、以迭代器、数目、字符为参数的insert、以迭代器、区间为参数的insert、以迭代器为参数的erase、以区间为参数的erase、以区间、string为参数的replace、以区间、C-string为参数的replace、以区间、C-string、长度为参数的replace、以区间、数目、字符为参数的replace、以源区间、目标区间为参数的replace

2）运用实例

- 示例程序一把一个string中的所有字符都转换为大写或小写
  * 注意，这里的tolower和toupper是旧式的C函数
  * 如果国别不同或者程序中需要多种国别，应该使用tolower和toupper的新形式

- 示例程序二使用自定义的查找规则和排序规则，以忽略大小写的方式对string进行比较和查找
  * 可以像pos - str.begin()这样来获得pos的索引位置，因为string的迭代器是随机存取迭代器
  * 可以自定义比较函数来进行忽略大小写的比较，也可以组合运用函数适配器来达到特别的目的，比如，compose_f_gx_hy(equal_to<int>(), ptr_fun(toupper), ptr_fun(toupper))

- 示例程序三展示了string迭代器的其他一些应用
  * 使用迭代器来初始化string对象
  * 通过迭代器来遍历string
  * 在reverse、sort等算法中使用迭代器来指明区间

- 示例程序四从标准输入读取string，并将字符插入到string中
  * 仿函数bothWhiteSpace用来检查相邻的是否都等于空格，这里使用cin的locale来调用isspace函数以检查字符是否为空格
  * unique_copy利用bothWhiteSpace来删除相邻的重复空格

14、国际化

- 为了应对那些依赖于字符类型的问题，string使用字符特性来提供相关细节
- 示例程序展示了一个为string定制的特性类型，使字符可以以忽略大小写的方式进行操作
  * 由于C++标准只为采用相同的字符类型和特性类型的的流定义I/O操作，所以，这里必须定义自己的operator <<
  * 同样的道理也适用于operator >>

15、效率

- C++标准并未规定string的实现细节，只是定义了它的接口
- 由于理念和侧重点的不同，不同的实现在速度和内存占用方面可能出现显著的差异
- 如果需要更快的速度，string的实现应该采用类似引用技术的概念，这样可以加速string的复制和赋值
  * 通过引用计数技术，甚至不再需要通过常量引用来传递string参数
  * 不过，基于灵活性和可移植性的考虑，一般还是应该采用常量引用的方式来传递参数

16、string和vector

- string和vector很相似，它们都是一种动态数组，因此，可以把string视为以字符为元素的vector
- 实用上可以将string当作STL容器来使用，但由于二者之间有一些本质上的不同，把string当作特殊的vector来使用还是存在一定的危险
- 它们之间最重要的差异在于二者的目标不同
  * vector的目标是处理和操作容器内的元素，而不是容器整体，所以，具体实现时会针对元素的操作进行优化
  * string主要是把容器视为整体，具体实现时会针对整个容器的复制和传递进行优化
- 不同的目标导致不同的实现方式，因此，string通常会采用引用计数，而vector绝对不会这样做
- 一般来说，可以把vector当作一个C-string来使用

三、详述string

1、内部的类型定义和静态变量

- 内部的类型定义和静态变量包括traits_type、value_type、size_type、difference_type、reference、const_reference、pointer、const_pointer、iterator、const_iterator、reverse_iterator、const_reverse_iterator、npos

2、生成、复制和销毁

- 生成、复制和销毁函数包括string、以string为参数的string、以string、索引为参数的string、以string、索引、数目为参数的string、以C-string为参数的string、以C-string、长度为参数的string、以数目、字符为参数的string、以区间为参数的string、~string

3、大小和容量

- 和大小相关的函数包括size、length、empty、max_size
- 和容量相关的函数包括capacity、reserve、以数目为参数的reserve

4、比较

- 比较操作符包括==、!=、<、>、<=、>=
- 比较操作符都有三个重载版本，以两个string为参数的、以string、C-string为参数的、以C-string、string为参数的
- 它们都按照字典顺序进行比较

- 比较函数包括以string为参数的compare、以索引、长度、string为参数的compare、以索引、长度、string、索引、长度为参数的compare、以C-string为参数的compare、以索引、长度、C-string为参数的compare、以索引、长度、C-string、长度为参数的compare
- 它们都按照traits::compare进行比较

5、字符存取

- 字符存取的函数包括以索引为参数的operator []、以索引为参数的operator []的常量版本、以索引为参数的at、以索引为参数的at的常量版本
  * 对于operator []，常量版本可以接受length()作为有效索引，但非常量版本将其视为无效索引
  * 对于at，不管是常量版本还是非常量版本，都将length()视为无效索引

6、产生C-string和字符数组

- 产生C-string和字符数组的函数包括c_str、data、以C-string、大小为参数的copy、以C-string、大小、索引为参数的copy
  * c_str返回一个C-string，包括字符串结束符‘\0’
  * data返回string中的所有字符，不包括字符串结束符‘\0’，因此，该返回值并不是一个有效的C-string
  * copy用来将string中的指定内容复制到指定的字符数组中，返回被复制的字符数目

7、更改内容

1）赋值

- 赋值的函数包括以string为参数的operator =、以string为参数的assign、以string、索引、数目为参数的assign、以C-string为参数的operator =、以C-string为参数的assign、以C-string、长度为参数的assign、以字符为参数的operator =、以数目、字符为参数的assign、以string为参数的成员函数swap、以string、string为参数的全局函数swap
- 尽量使用swap来取代赋值操作，因为它们更快

2）添加字符

- 添加字符的函数包括以string为参数的operator +=、以string为参数的append、以string、索引、数目为参数的append、以C-string为参数的operator +=、以C-string为参数的append、以C-string、长度为参数的append、以数目、字符为参数的append、以字符为参数的operator +=、以字符为参数的push_back、以区间为参数的append

3）插入字符

- 插入字符的函数包括以索引、string为参数的insert、以目标索引、string、源索引、数目为参数的insert、以索引、C-string为参数的insert、以索引、C-string、长度为参数的insert、以索引、数目、字符为参数的insert、以迭代器、数目、字符为参数的insert、以迭代器、字符为参数的insert、以迭代器、区间为参数的insert

4）擦除字符

- 擦除字符的函数包括clear、erase、以索引为参数的erase、以索引、长度为参数的erase、以迭代器为参数的erase、以区间为参数的erase

5）改变大小

- 改变大小的函数包括以数目为参数的resize、以数目、字符为参数的resize

6）替换字符

- 替换字符的函数包括以索引、长度、string为参数的replace、以区间、string为参数的replace、以目标索引、长度、string、源索引、数目为参数的replace、以索引、长度、C-string为参数的replace、以区间、C-string为参数的replace、以索引、目标长度、C-string、源长度为参数的replace、以区间、C-string、长度为参数的replace、以索引、长度、数目、字符为参数的replace、以区间、数目、字符为参数的replace、以目标区间、源区间为参数的replace

8、查找

1）查找单一字符

- 查找单一字符的函数包括以字符为参数的find、以字符、索引为参数的find、以字符为参数的rfind、以字符、索引为参数的rfind

2）查找子字符串

- 查找子字符串的函数包括以string为参数的find、以string、索引为参数的find、以string为参数的rfind、以string、索引为参数的rfind、以C-string为参数的find、以C-string、索引为参数的find、以C-string为参数的rfind、以C-string、索引为参数的rfind、以C-string、索引、长度为参数的find、以C-string、索引、长度为参数的rfind

3）查找第一个匹配的字符

- 查找第一个匹配的字符的函数包括以string为参数的find_first_of、以string、索引为参数的find_first_of、以string为参数的find_first_not_of、以string、索引为参数的find_first_not_of、以C-string为参数的find_first_of、以C-string、索引为参数的find_first_of、以C-string为参数的find_first_not_of、以C-string、索引为参数的find_first_not_of、以C-string、索引、长度为参数的find_first_of、以C-string、索引、长度为参数的find_first_not_of、以字符为参数的find_first_of、以字符、索引为参数的find_first_of、以字符为参数的find_first_not_of、以字符、索引为参数的find_first_not_of
- 这些函数的返回值类型均为size_type

4）查找最后一个匹配的字符

- 查找最后一个匹配的字符的函数包括以string为参数的find_last_of、以string、索引为参数的find_last_of、以string为参数的find_last_not_of、以string、索引为参数的find_last_not_of、以C-string为参数的find_last_of、以C-string、索引为参数的find_last_of、以C-string为参数的find_last_not_of、以C-string、索引为参数的find_last_not_of、以C-string、索引、长度为参数的find_last_of、以C-string、索引、长度为参数的find_last_not_of、以字符为参数的find_last_of、以字符、索引为参数的find_last_of、以字符为参数的find_last_not_of、以字符、索引为参数的find_last_not_of
- 这些函数的返回值类型均为size_type

9、子字符串及字符串的连接

- 子字符串及字符串的连接的函数包括substr、以索引为参数的substr、以索引、长度为参数的substr、以string、string为参数的operator +、以string、C-string为参数的operator +、以C-string、string为参数的operator +、以string、字符为参数的operator +、以字符、string为参数的operator +

10、I/O函数

- I/O函数包括operator <<、operator >>、不带分隔符参数的getline、带分隔符参数的getline

11、产生迭代器

- 产生迭代器的函数包括begin及其常量版本、end及其常量版本、rbegin及其常量版本、rend及其常量版本

12、对配置器的支持

- 对配置器的支持包括allocator_type、get_allocator
- string的所有构造函数都包括可选的配置器参数
- 如果一个string的初始值被设为另一个string，则配置器也会被复制

<2023-1-28>
