第十章 特殊容器

一、stack
  1、核心接口
  2、stack运用实例
  3、模板类stack的细节
    1）类型定义
    2）各项操作
  4、一个自定义的stack类
二、queue
  1、核心接口
  2、queue运用实例
  3、模板类queue的细节
    1）类型定义
    2）各项操作
  4、一个自定义的queue类
三、priority queue
  1、核心接口
  2、priority queue运用实例
  3、模板类priority_queue的细节
    1）类型定义
    2）构造函数
    3）其他操作
四、bitset
  1、bitset运用实例
    1）将bitset当作一组标志
    2）在I/O中利用bitset表示二进制
  2、模板类bitset的细节
    1）生成、复制和销毁
    2）非更易性操作
    3）更易性操作
    4）operator []
    5）位操作符
    6）类型转换操作
    7）I/O操作

- 除了STL容器之外，C++标准程序库还提供了一些为了满足特殊需求而设计的容器
  * 容器适配器：这些容器适配器对标准的STL容器进行适配，使之满足特殊的需求，包括stack、queue、priority queue，其中，priority queue是根据排序规则对元素进行自动排序的队列，队列中的“下一个”元素总是具有最高的优先级
  * bitset：它其实就是一个位域，包含任意数量的位，不过一旦确定下来就不能再改变，可以被看作一个位的容器

一、stack

- 模板类stack实现了一个栈，可以使用push将任意数量的元素放置于栈中，也可以使用pop将元素按照和放置顺序相反的顺序移除，即，后进先出
- 另外，C++标准程序库还提供了一个长度可变的特殊容器，vector<bool>
- 要使用stack，需要包含头文件<stack>

- 模板类stack定义在<stack>中
  * 第一个模板参数指明元素的类型
  * 第二个模板参数定义栈内部用来存放元素的实际容器，默认情况下是deque，选择deque而不是vector是因为前者在移除元素时会释放内存，并且不必在重新分配内存时复制全部的元素
- 实际上，stack只是把各项操作转换为对内部容器的对应调用，所以，可以使用任何序列式容器来实现它，只要能支持back、push_back、pop_back等操作即可，比如，vector或list

1、核心接口

- stack的核心接口就是三个成员函数
  * push将一个元素放置到栈中
  * top返回栈中的“下一个”元素
  * pop从栈中移除“下一个”元素
- pop移除下一个元素，但并不会返回它，而top返回一个元素，但不会移除它
- 如果栈为空，调用top或pop都会导致未定义的行为，可以通过成员函数size或empty来判断队列是否为空

2、stack运用实例

- 示例程序展示了stack的用法

3、模板类stack的细节

- 模板类stack的接口非常小，很容易阅读并理解它

1）类型定义

- 涉及的类型包括value_type、size_type、container_type

2）各项操作

- 涉及的各项操作包括stack、以容器为参数的stack、size、empty、以元素为参数的push、top及其常量版本、pop、==/!=/</>/<=/>=
  * empty与判断size() == 0等效，但速度更快
  * top的第一种形式返回一个元素的引用，通过它可以就地修改栈中的元素
  * 两个栈相等是指它们的元素数目相等且每个对应元素也一一相等
  * 栈之间的大小比较是按照字典顺序进行的

4、一个自定义的stack类

- 标准的stack将运行速度放在方便性和安全性之前，但通常并不需要这样做
- 这里是一个自定义的stack类，主要包括以下优势
  * pop会返回下一个元素
  * 如果栈为空，pop和top都会抛出异常
  * 此外，不常用的比较操作符被略去了
- 示例程序展示了自定义的stack模板类的用法，最后一个pop调用故意触发了一个异常，需要捕捉它以避免未定义的行为

二、queue

- 模板类queue实现了一个队列，可以使用push将任意数量的元素放置于队列中，也可以使用pop将元素按照放置顺序移除，即，先进先出
- 换句话说，queue是一种典型的缓冲区结构
- 要使用queue，需要包含头文件<queue>

- 模板类queue定义在<queue>中
  * 第一个模板参数指明元素的类型
  * 第二个模板参数定义栈内部用来存放元素的实际容器，默认情况下是deque
- 实际上，queue只是把各项操作转换为对内部容器的对应调用，所以，可以使用任何序列式容器来实现它，只要能支持front、back、push_back、pop_front等操作即可，比如list

1、核心接口

- queue的核心接口就是四个成员函数
  * push将一个元素放置到队列中
  * front返回队列中的“下一个”元素，也就是第一个元素
  * back返回队列中的最后一个元素
  * pop从队列中移除“下一个”元素
- pop移除一个元素，但并不会返回它，而front和back返回下一个元素或最后一个元素，但不会移除它
- 如果队列为空，调用front、back或pop都会导致未定义的行为，可以通过成员函数size或empty来判断队列是否为空

2、queue运用实例

- 示例程序展示了queue的用法

3、模板类queue的细节

- 和模板类stack一样，模板类queue的实现也很清晰易懂

1）类型定义

- 涉及的类型包括value_type、size_type、container_type

2）各项操作

- 涉及的各项操作包括queue、以容器为参数的queue、size、empty、以元素为参数的push、front及其常量版本、back及其常量版本、pop、==/!=/</>/<=/>=
  * empty与判断size() == 0等效，但速度更快
  * front和back的第一种形式都返回一个元素的引用，通过它可以就地修改队列中的元素
  * 两个队列相等是指它们的元素数目相等且每个对应元素也一一相等
  * 队列之间的大小比较是按照字典顺序进行的

4、一个自定义的queue类

- 标准的queue将运行速度放在方便性和安全性之前，但通常并不需要这样做
- 这里是一个自定义的stack类，主要包括以下优势
  * pop会返回下一个元素
  * 如果队列为空，front和pop都会抛出异常
  * 此外，不常用的比较操作符和back被略去了
- 示例程序展示了自定义的queue模板类的用法，最后一个pop调用故意触发了一个异常，需要捕捉它以避免未定义的行为

三、priority queue

- 模板类priority_queue实现了一个优先队列，其中的元素被按照优先顺序读取
  * 它的接口和queue类似，可以使用push将任意数量的元素放置于优先队列中，也可以使用top/pop来存取/移除下一个元素
  * 这里的“下一个元素”并不是第一个被放置的元素，而是优先级最高的元素，也就是说，优先队列中的元素已经根据其值进行了排序
- 要使用priority_queue，需要包含头文件<queue>

- 和模板类queue一样，priority_queue也定义在<queue>中
  * 第一个模板参数指明元素的类型
  * 第二个模板参数定义优先队列内部用来存放元素的实际容器，默认情况下是vector
  * 第三个模板参数定义元素的排序规则，默认情况下是less，它利用operator <形成降序排列，即，下一个元素是数值最大的元素，如果存在多个数值相等的元素，则无法确定哪一个会是首选
- 实际上，priority_queue只是把各项操作转换为对内部容器的对应调用，所以，可以使用任何序列式容器来实现它，只要能支持随机存取迭代器和front、push_back、pop_back等操作即可
- 之所以需要支持随机存取迭代器，是因为priority_queue内部用到的堆算法需要使用它

1、核心接口

- priority_queue的核心接口就是三个成员函数
  * push将一个元素放置到优先队列中
  * top返回优先队列中的“下一个”元素
  * pop从优先队列中移除“下一个”元素
- pop移除一个元素，但并不会返回它，而top返回下一个元素，但不会移除它
- 如果优先队列为空，调用top或pop都会导致未定义的行为，可以通过成员函数size或empty来判断优先队列是否为空

2、priority queue运用实例

- 示例程序展示了priority_queue的用法

3、模板类priority_queue的细节

- 和模板类stack、queue一样，模板类priority_queue的实现也很清晰易懂
  * 可以看出，priority_queue在内部使用了STL的堆算法
  * 和stack、queue不同的是，priority_queue没有实现比较操作符

1）类型定义

- 涉及的类型包括value_type、size_type、container_type

2）构造函数

- 构造函数包括priority_queue、以容器为参数的priority_queue、以排序规则、容器为参数的priority_queue、以区间为参数的priority_queue、以区间、排序规则为参数的priority_queue、以区间、排序规则、容器为参数的priority_queue

3）其他操作

- 其他操作包括size、empty、以元素为参数的push、top、pop
  * empty与判断size() == 0等效，但速度更快
  * top返回下一个元素，即，所有元素中数值最大的那个，如果存在若干相等的最大元素，则无法确定会返回哪一个

四、bitset

- bitset是一个内含位或布尔值的大小固定的数组，可以用于管理各种标志并以标志的任意组合来表现变量
  * 传统的C和C++程序通常使用类型long来表示位数组，再通过&、|、~等位操作符来操作位
  * bitset的优点是可以容纳任意数量的位，并提供各种操作，不过，位的数量是通过模板参数决定的，一旦确定就不能再改变
- 如果需要一个可变长度的位容器，应该考虑使用vector<bool>
- 要使用bitset，需要包含头文件<bitset>

- 模板类bitset定义在<bitset>中，它只有一个模板参数，它是一个不带正负号的整数，用来指定位的数量
- 不同的模板参数意味着不同的bitset类型，不同的bitset类型之间不能进行比较和组合

1、bitset运用实例

1）将bitset当作一组标志

- 示例程序使用bitset来管理一组标志
  * 每个标志都是通过枚举类型定义的值，这些值代表对应的位在bitset中的位置
  * 这样，该bitset变量就可以代表多种颜色的任意组合

2）在I/O中利用bitset表示二进制

- 示例程序使用bitset在整数值和位序列之间相互转化
  * 可以将整数值转换为与各种类型相符的bitset
  * 也可以将二进制字符串转换为bitset，再使用成员函数to_ulong转换为整数值，如果bitset无法按照unsigned long来表现这个值，它会抛出一个异常

2、模板类bitset的细节

1）生成、复制和销毁

- bitset定义了一些特殊的构造函数，但没有提供拷贝构造函数、赋值操作符和析构函数，因此，bitset的拷贝和赋值操作都是采用默认的按位拷贝的行为
- 构造函数包括bitset、以unsigned long为参数的bitset、以string为参数的bitset、以string、索引为参数的bitset、以string、索引、数目为参数的bitset
  * 字符串中只能包含字符‘0’或者‘1’，否则会抛出invalid_argument异常
  * 如果字符串中的字符数量少于需要的数量，则前面多余的位会被设置为0
  * 如果字符串中的字符数量多于需要的数量，则多出来的字符会被忽略
  * 如果索引大于字符串的长度，则会抛出out_of_range异常

2）非更易性操作

- 非更易性操作包括size、count、any、none、以索引为参数的test、==/!=

3）更易性操作

- 更易性操作包括set、以索引为参数的set、以索引、布尔值为参数的set、reset、以索引为参数的reset、flip、以索引为参数的flip、^=/|=/&=/<<=/>>=

4）operator []

- operator []包括以索引为参数的operator []及其常量版本
  * 第一种形式返回一个引用，可以用来改变元素的值
  * 该引用其实是一个特殊的临时对象bitset<>::reference，它作为位的代理可以改变位的内容，这包括五种操作，以布尔值为参数的operator =、以reference为参数的operator =、flip、类型转换操作符bool、位操作符~

5）位操作符

- 位操作符包括~、<<、>>、&、|、^，它们不改变原来的bitset，而是返回一个新值

6）类型转换操作

- 类型转换操作包括to_ulong、to_string

7）I/O操作

- I/O操作包括operator >>、operator <<
  * operator >>的读取操作会一直进行下去，直到遇到这三种情况之一，读取结束、遇到了end-of-file符号或者下一个字符既不是‘0’也不是‘1’

<2022-2-3>
