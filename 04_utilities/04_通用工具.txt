第四章 通用工具

一、pair
  1、make_pair
  2、pair运用实例
二、auto_ptr
  1、auto_ptr的设计动机
  2、auto_ptr所有权的转移
    1）起点和终点
    2）缺陷
  3、auto_ptr用作成员
  4、auto_ptr的错误运用
  5、auto_ptr运用实例
  6、auto_ptr实现细节
    1）构造函数、赋值操作符和析构函数
    2）数值存取
    3）数值操作
    4）转换
    5）auto_ptr的实现的范例
三、数值极限
  1、numeric_limits
  2、numeric_limits使用范例
四、辅助函数
  1、选择较小值和较大值
  2、两值交换
五、辅助性的比较操作符
六、头文件<cstddef>和<cstdlib>
  1、<cstddef>内的各种定义
  2、<cstdlib>内的各种定义

- 本章讲解C++标准程序库中的通用工具，包括一些短小精干的类和函数，用来执行最一般的工作
  * 一些通用类型
  * 一些重要的C函数
  * 数值极限
- 大部分通用工具在C++标准规格的第20款中描述，定义在头文件<utility>中
- 还有一部分与标准程序库中的一些主要组件一起描述，比如，有些通用辅助函数定义在头文件<algorithm>中，但它们并不是算法

一、pair

- pair可以把两个值视为一个整体
- C++标准程序库中多处使用到它，比如，map和multimap使用它来管理键-值对的元素
- 任何函数需要返回两个值，也可以使用它

- 要使用pair，需要包含头文件<utility>
  * 注意，pair被定义为struct，因此，其成员均为公有的
  * 默认构造函数会分别调用两个类型的默认构造函数对first和second进行初始化
  * 这里使用了模板形式的拷贝构造函数，是因为在其构造过程中可能会用到隐式类型转换
- 为了比较两个pair对象，C++标准程序库提供了惯用的操作符，operator ==和operator <
  * 两个pair对象的所有元素都相等，则被视为相等
  * 如果两个pair对象不相等，先比较第一个元素，如果相等再比较第二个元素

1、make_pair

- make_pair是一个模板函数，不需要写出类型，就可以生成一个pair对象
- 在为一个接受pair作为参数的函数传递参数时，make_pair使得这个操作更加容易
  * 即使这两个值的类型并不完全符合要求，make_pair也可以完成必要的隐式类型转换
  * 当然，明确地指出类型可以产生准确的类型，这在存在重载函数时尤为重要

2、pair运用实例

- C++标准程序库中大量使用了pair
  * map和multimap容器的元素使用的就是pair
  * 凡是需要返回两个值的函数，也会使用pair

二、auto_ptr

- auto_ptr是一种智能指针，可以防止在抛出异常时发生资源泄露

1、auto_ptr的设计动机

- 一个函数的操作经常是以下列模式进行的
  * 获取一些资源
  * 执行一些动作
  * 释放获取的资源
- 如果获取的资源被绑定在局部对象上，当函数退出时，局部对象的析构函数得以调用，资源被自动释放
- 不过，如果资源是显式获取的，并且没有绑定到局部对象上，就必须显式地释放，比如，调用delete，但程序员往往会忘记这个操作，特别是在函数中存在多个return语句时
- 发生异常时，情况会更加糟糕，delete语句甚至得不到机会被执行，常见办法是捕捉异常并执行delete操作，这将使代码变得复杂而容易出错

- 智能指针可以保证，无论在什么情况下自己被销毁时，都会释放所拥有的资源，auto_ptr正是这样的一种指针
- auto_ptr是它所指向的对象的所有者，当它被销毁时，该对象也会被销毁
- auto_ptr要求一个对象只能有一个所有者，所以，不能使用一般指针的赋值方式来为auto_ptr赋值

2、auto_ptr所有权的转移

- auto_ptr基于一种严格的所有权，绝对不能允许多个auto_ptr拥有同一个对象的情况
- 所以，auto_ptr的拷贝构造函数和赋值操作符都会发生对象的所有权的转移，源对象会发生变动，只剩一个null在手了

1）起点和终点

- 所有权的转移使得auto_ptr产生了一种特殊用法，可能出现在下列两种情形
  * auto_ptr被以值传递的方式传递给一个函数，该函数是auto_ptr中数据的终点，那么在该函数退出时，auto_ptr指向的资源就会被自动删除
  * auto_ptr被一个函数作为返回值返回，该函数是auto_ptr中数据的起点，其所有权被转移给调用者

2）缺陷

- auto_ptr本身就包含所有权的语义，所以，如果不希望转移所有权，就不要把auto_ptr用作函数的参数或者返回值
- 如果以引用传递的方式传递auto_ptr，情况会更加难以捉摸，因为函数甚至无法确定所有权是否发生了转移，所以，应该尽量避免这种糟糕的设计

- 把auto_ptr定义为const类型可以避免向函数转移所有权，降低不经意地转移所有权的风险，当意外发生所有权的转移时，会导致编译错误
- 这里的const并不意味着不能更改auto_ptr指向的对象，而是不能更改auto_ptr的所有权

3、auto_ptr用作成员

- 在类中使用auto_ptr作为成员可以避免资源泄露，尤其是类中存在两个指针，第一个指针分配成功，而第二个指针分配失败的情况
- 同样，可以使用const auto_ptr来避免意外的所有权转移

4、auto_ptr的错误运用

- 关于如何正确使用auto_ptr的一些要点
  * auto_ptr之间不能共享所有权，这会带来灾难性的后果
  * 不存在针对数组设计的auto_ptr，因为它是通过delete而不是delete []来释放指向的对象
  * auto_ptr并不是一个万能的智能指针，它不使用引用计数来进行管理，因此，不适合多个智能指针共享同一个对象的情形
  * auto_ptr不满足STL容器对其内部元素的基本要求，所以，绝对不要将auto_ptr作为容器的元素
- 不幸的是，有时候误用auto_ptr的程序仍然能够顺利运行，从这个角度看，auto_ptr并不比一般指针安全

5、auto_ptr运用实例

- operator <<的第二个参数是一个const auto_ptr的引用，所以不会发生所有权的转移
- 注意，不能像一般的指针那样通过赋值操作来初始化一个auto_ptr，这是因为根据一般的指针来构造auto_ptr对象的构造函数被声明为explicit
- 这里再次展示了使用const auto_ptr可以避免意外的所有权转移

6、auto_ptr实现细节

- auto_ptr位于头文件<memory>

1）构造函数、赋值操作符和析构函数

- auto_ptr()：构造一个空的auto_ptr，不拥有任何对象
- auto_ptr(T* ptr)：构造一个的auto_ptr，拥有ptr所指的对象，*this成为该对象的唯一所有者，注意，ptr不能是new []操作符返回的数组指针
- auto_ptr(auto_ptr)：构造一个auto_ptr，将参数所指的auto_ptr的所有权转移过来，该函数有一个重载的模板函数，可以通过隐式类型转换构造出合适的auto_ptr
- operator =：删除原来拥有的对象，将源auto_ptr的所有权转移过来，和拷贝构造函数类似，该函数也有一个重载的模板函数
- ~auto_ptr：如果拥有某个对象，就删除它

2）数值存取

- get()：获得拥有的对象的地址
- operator *：获得拥有的对象
- operator ->：成员存取操作符

3）数值操作

- release()：放弃对对象的所有权
- reset(T*)：用参数所指的对象重新设置auto_ptr

4）转换

- auto_ptr的其余内容涉及非常精致的技巧，可以对非常量auto_ptr进行拷贝和赋值，但不可以对常量auto_ptr进行拷贝和赋值
- 这实际上包含了两个需求
  * 可以将auto_ptr作为右值传递给函数或者由函数返回
  * 拷贝auto_ptr时，源auto_ptr必须放弃自己的所有权，这意味着源auto_ptr必须能够被修改

- 一般的拷贝构造函数当然可以拷贝右值，但必须将参数声明为一个常量引用，这意味着拷贝构造函数中用到的指针不得不声明为mutable，这样才能在拷贝构造函数中修改它，但这样却允许拷贝常量auto_ptr，并转移其所有权，这与原本的常量性背道而驰
- 变通的方法是，找出一种机制将右值转化为左值，但直接转换为引用无法奏效，这就是引入auto_ptr_ref类型的原因，它可以帮助将右值转化为左值，这一机制的理论基础是重载和模板参数推导规则之间的细微差别
- 如果编译器的版本还不能清晰地区分这种细微差别，使用auto_ptr将会很危险，所有权可能旁落他人之手

5）auto_ptr的实现的范例

- 示例程序展示了一个符合标准的auto_ptr的实现

三、数值极限

- 一般来说，数值类型的极限是一个与平台相关的特性
- C++标准程序库通过模板来提供这些极限，取代了C中采用的预处理器常数
  * C中的预处理器常数仍然可以使用，整数定义在<climits>和<limits.h>中，浮点数定义在<cfloat>和<float.h>中
  * 新的模板方法具有两个优点，一是提供了很好的类型安全性，二是程序员可以借此写出一些利用这些极限的模板

1、numeric_limits

- 使用模板通常是为了对所有的类型一次性地提供一个通用的解决方案，并在必要时为每个类型提供共同的接口
- 具体的方法是，不但提供通用的模板，而且提供特化版本

- numeric_limits就是这样的一个典型例子
- 通用的numeric_limits模板及其特化版本都定义在头文件<limits>中，特化版本涵盖了所有基本类型
- 示例程序展示了float类型的特化版本的numeric_limits实现

2、numeric_limits使用范例

- 示例程序展示了某些极限的可能的运用范例
  * 程序的输出结果和平台相关
  * numeric_limits<string>的is_specialized返回false，表示该类型没有极限

四、辅助函数

1、选择较小值和较大值

- min返回两个数之间的较小者，max返回两个数之间的较大者，它们都定义在头文件<algorithm>中
- 它们还有一个版本，可以接受一个额外的参数作为比较规则，该参数可以是一个函数或者仿函数

2、两值交换

- swap用来交换两个对象的值，它也定义在头文件<algorithm>中
- swap正常工作的前提是，它所依赖的拷贝构造和赋值操作都可以正常进行
- swap的最大优势是，通过模板特化和函数重载，可以为更复杂的类型提供特殊的实现，比如，只交换对象的内部成员而不必赋值整个对象

五、辅助性的比较操作符

- 名字空间std::rel_ops中定义了!=、>、<=、>=四个比较操作符，它们是利用==和<比较操作符实现的
- 这意味着，只要一个类型实现了==和<比较操作符，只需要加上using namespace std::rel_ops，就可以自动获得所有六个比较操作符的功能

- 有的实现会使用两个不同的类型来定义上述比较操作符的两个操作数，这样做的好处是，只要这两个操作数事实上可以进行比较，这些比较操作符就可以正常工作，而不必是同一种类型
- 但是注意，这并非C++标准程序库支持的做法，可能付出可移植性方面的代价

六、头文件<cstddef>和<cstdlib>

- 头文件<cstddef>和<cstdlib>和C中的对应头文件兼容，是更新后的版本

1、<cstddef>内的各种定义

- NULL：指针的无效值
- size_t：无符号的类型，用来表示大小
- ptrdiff_t：有符号的类型，用来表示指针之间的距离
- offsetof：表示一个成员在struct或union中的偏移量

2、<cstdlib>内的各种定义

- EXIT_SUCCESS和EXIT_FAILURE：可以作为exit函数的参数或者main函数的返回值
- atexit用来登记程序退出时将被依次调用的函数，不管是通过exit还是通过main函数
- exit和abort用来在任何位置终止程序，不必返回到main函数中
  * exit会销毁所有的静态对象，将所有的缓冲区清空，关闭所有的I/O通道，然后终止程序
  * abort会立刻终止程序，不进行任何清理工作
- 这两个函数都不会销毁局部对象，要确保局部对象的析构函数被调用，应该使用异常处理机制或者正常返回到main函数中再退出程序

<2022-12-25>
