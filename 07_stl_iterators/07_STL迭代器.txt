第七章 STL迭代器

一、迭代器头文件
二、迭代器类别
  1、输入迭代器
  2、输出迭代器
  3、前向迭代器
  4、双向迭代器
  5、随机存取迭代器
  6、vector迭代器的递增和递减
三、和迭代器相关的辅助函数
  1、advance可以让迭代器前进
  2、distance可以计算迭代器之间的距离
  3、iter_swap可以交换两个迭代器指向的内容
四、迭代器适配器
  1、逆向迭代器
    1）一般迭代器和逆向迭代器
    2）将逆向迭代器转回一般迭代器
  2、插入型迭代器
    1）插入型迭代器的功能
    2）插入型迭代器的种类
    3）关联式容器的用户自定义插入型迭代器
  3、流迭代器
    1）输出流迭代器
    2）输入流迭代器
    3）流迭代器的使用范例
五、迭代器特性
  1、为迭代器编写泛型函数
    1）运用迭代器的类型
    2）运用迭代器的类别
    3）distance的具体实现
  2、自定义的迭代器

一、迭代器头文件

- 所有的容器都定义了自己的迭代器类型，因此，在使用某种容器的迭代器时，不需要包含额外的头文件
- 不过，有几种特殊的迭代器定义在头文件<iterator>中，比如逆向迭代器，容器为了定义自己的逆向迭代器类型，一般也已包含它

二、迭代器类别

- 迭代器是一种能够遍历某个集合中所有元素的对象，它提供和指针一致的接口
- 迭代器是一个抽象概念，任何东西，只要其行为类似迭代器，它就是一种迭代器
- 不同的迭代器具有不同的能力
  * 由于某些算法需要特定的能力，所以，迭代器的能力是很重要的概念
  * 排序算法需要迭代器具有随机存取的能力，否则执行效率会很低

- 基于这个原因，迭代器被分为不同的类别
  * 输入迭代器：向前读取，包括istream
  * 输出迭代器：向前写入，包括ostream、inserter
  * 前向迭代器：向前读取和写入
  * 双向迭代器：向前和向后读取和写入，包括list、set、multiset、map、multimap
  * 随机存取迭代器：随机存取，可以读取也可以写入，包括vector、deque、string、数组

1、输入迭代器

- 输入迭代器只能一次一个向前遍历元素
  * 注意，输入迭代器只能读取元素一次
  * 几乎所有的迭代器都具备输入迭代器的能力
- 纯粹的输入迭代器就是从标准输入读取数据的迭代器
  * 同一个值不会被读取两次
  * 一旦从流中读取了一个数据，下一次读取的就会是下一个数据

- 尽可能使用前置operator ++操作符，它不需要传回旧值，比后置operator ++具有更好的性能
- 这条规则也适用于operator --，不过需要注意的是，输入迭代器并不提供operator --操作符

2、输出迭代器

- 输出迭代器的作用是将元素一个一个地写入，即，一个元素一个元素地赋予新值
  * 同样，输出迭代器也不能对同一集合进行两次遍历
  * 几乎所有的迭代器都具备输出迭代器的能力
- 注意，输出迭代器不需要比较操作，无法检验它是否有效，程序员能做的就是写入再写入

- 纯粹的输出迭代器就是向标准输出输出数据的迭代器，输出第一个数据后再输出第二个数据，第二个数据一定是跟在第一个数据后面，而不会覆盖第一个数据
- 输出迭代器的另一个例子是inserter，在插入第一个元素之后再插入第二个元素，第二个元素不会覆盖第一个元素

3、前向迭代器

- 前向迭代器是输入迭代器和输出迭代器的结合，它具有输入迭代器的全部功能和输出迭代器的大部分功能
- 与输入迭代器和输出迭代器不同，前向迭代器可以多次指向一个集合中的同一个元素，并多次处理同一个元素

- 前向迭代器不具备输出迭代器的全部功能，是因为存在一个约束条件，使得某些对输出迭代器有效的程序对前向迭代器无效
  * 对于输出迭代器，不需要检查它是否到达集合的末尾，可以直接写入数据，事实上，由于输出迭代器不提供比较操作，因此无法将它与集合的尾端迭代器进行比较
  * 对于前向迭代器，在获取其中的数据之前，必须检查迭代器的有效性，避免针对集合的尾端迭代器进行数据获取操作

4、双向迭代器

- 双向迭代器是在前向迭代器的基础上增加了回头遍历的功能
- 换句话说，双向迭代器支持operator --，用来执行后退操作

5、随机存取迭代器

- 随机存取迭代器在双向迭代器的基础上增加了随机存取功能，为此，它必须提供迭代器的算术运算能力
  * 能够进行加减运算
  * 能够处理距离
  * 能够通过<、>关系操作符进行比较
- 支持随机存取迭代器的类型包括vector、deque、字符串、string、wstring、数组

- 只有随机存取迭代器才可以使用operator <作为循环是否结束的判断标准
- 注意，不要将迭代器移动到尾端迭代器之后的位置，这将导致未定义的行为

6、vector迭代器的递增和递减

- 迭代器的递增和递减有一个奇怪的问题，一般情况下，可以递增或递减临时迭代器，但是，对于vector和string则不一定行
  * vector的迭代器一般被实现为指针，而C++不允许修改任何基本类型的临时值，包括指针
  * 但C++允许修改struct或class的临时值，所以，如果迭代器被实现为struct或者class，则对其递增或递减可以编译通过
- deque、list、set/multiset、map/multimap总是可以编译通过是因为它们的迭代器不可能被实现为指针
- string也有类似的问题，因为string的迭代器通常也被实现为指针

三、和迭代器相关的辅助函数

- C++标准程序库为迭代器提供了三个辅助函数，advance、distance、iter_swap
  * 前两个函数为迭代器提供了本来只有随机存取迭代器才具有的能力
  * 第三个函数用来交换两个迭代器所指向的元素的值

1、advance可以让迭代器前进

- advance可以使迭代器的位置前进或者后退，幅度由参数决定
- advance并不检查迭代器是否会超出有效范围
- advance会根据迭代器的类别采用最佳的方案，这归功于迭代器特性的运用
  * 对于随机存取迭代器，该函数简单地调用operator +=或operator -=，具有常数复杂度
  * 对于其他迭代器，该函数不得不多次调用operator ++或operator --，具有线性复杂度

- 如果希望程序能够轻松地切换容器和迭代器的类型，应该使用advance而不是operator +=或operator -=
  * 当然，这可能会付出性能上的代价，这正是随机存取迭代器提供operator +=的原因
  * 另外，operator +=或operator -=会传回一个位置，可以作为另一个更大的表达式的一部分，advance则没有返回值

2、distance可以计算迭代器之间的距离

- distance用来处理两个迭代器之间的距离
  * 两个迭代器必须指向同一个容器
  * 如果不是随机存取迭代器，必须能够从第一个迭代器到达第二个迭代器
- distance会根据迭代器的类别采用最佳的方案，这归功于迭代器标志的运用
  * 对于随机存取迭代器，该函数简单地通过减法运算完成，具有常数复杂度
  * 对于其他迭代器，该函数不得不多次调用operator ++并返回递增的次数，具有线性复杂度

- 如果希望程序能够轻松地切换容器和迭代器的类型，应该使用distance而不是operator -
  * 当然，这可能会付出性能上的代价
  * 另外，第一个迭代器绝对不能位于第二个迭代器之后，这会导致未定义的行为
  * 如果不确定哪个迭代器在前，就必须先分别计算出两个迭代器到起点的距离，然后根据这两个距离来判断
- 在STL的早期版本中，distance的函数签名与现在有所不同，它通过参数返回距离值，无法直接用在表达式中，可以通过自己编写一个包装函数来解决这个问题

3、iter_swap可以交换两个迭代器指向的内容

- iter_swap用来交换两个迭代器所指向的元素的值
  * 两个迭代器的类型可以不同，但它们指向的两个值必须可以相互赋值
  * 注意，对于vector，如果针对临时迭代器使用iter_swap，会导致失败

四、迭代器适配器

- 迭代器适配器是一类特殊的迭代器，它们使算法可以以逆向模式或插入模式进行工作，也可以和流配合工作

1、逆向迭代器

- 逆向迭代器重新定义了递增和递减运算，使其行为正好倒置过来
  * 使用逆向迭代器，算法会以逆向的顺序处理元素
  * 所有的标准容器都允许通过逆向迭代器来遍历元素

1）一般迭代器和逆向迭代器

- 一般迭代器可以转化为逆向迭代器，当然，这个一般迭代器必须具有双向移动的能力
- 转化之后的迭代器的逻辑位置发生了变化
  * 逆向迭代器所定义的区间并不包括起点，而是包括了终点
  * 逆向迭代器实际指向的位置和逻辑上指向的元素位置并不相同，它逻辑上指向的是前一个元素
- 这样做的优点是，对于一个由两个迭代器定义的区间，转换为逆向迭代器后所有的元素仍然有效

2）将逆向迭代器转回一般迭代器

- 为了将逆向迭代器转回一般迭代器，逆向迭代器提供了成员函数base
- 和一般迭代器转化为逆向迭代器一样，转化后的一般迭代器实际指向的位置不变，变化的是它指向的逻辑位置

2、插入型迭代器

- 插入型迭代器用来将赋值操作转换为插入操作
  * 通过这种迭代器，算法可以用插入行为代替覆盖行为
  * 所有的插入型迭代器都属于输出迭代器，因此，它只提供插入新值的能力

1）插入型迭代器的功能

- 通常情况下，算法会将值赋给目标迭代器指向的元素，比如copy
- 插入型迭代器将这样的赋值操作转化为插入操作
  * 首先，通过operator *获得迭代器的位置，它只是简单地返回*this，因此，*pos和pos等价
  * 然后，通过operator =来调用容器的push_back、push_front或insert来插入新值
- 所以，对于插入型迭代器，可以使用*pos = value来赋值，也可以使用pos = value来赋值，二者事实上都是插入新值，不过，从概念上讲，正确的赋值表达式是前者
- 同样，不管是operator ++还是operator--，它们都只是简单地返回*this，不会改变插入型迭代器的位置

2）插入型迭代器的种类

- C++标准程序库提供了三种插入型迭代器，Back插入型迭代器、Front插入型迭代器和一般性插入型迭代器，它们的区别仅在于插入的位置
- 当然，容器必须支持插入型迭代器所调用的函数，否则，该插入型迭代器就不可用于该容器

- Back插入型迭代器通过成员函数push_back将新值添加到容器的尾部，所以只能被用于vector、deque、list、string
  * back_inserter可以简化Back插入型迭代器的初始化
  * 在调用copy通过Back插入型迭代器为vector插入元素时，要为其预留足够的空间，否则可能会因为源迭代器失效而失败
  * string也提供了push_back成员函数，因此，可以通过Back插入型迭代器为其添加字符

- Front插入型迭代器通过成员函数push_front将新值添加到容器的首部，所以只能被用于deque、list
  * front_inserter可以简化Back插入型迭代器的初始化
  * Front插入型迭代器以逆序方式插入新元素，因为它总是把后一个元素插入到前一个元素的前面

- 一般性插入型迭代器则可以接受一个额外的参数来指定要插入的位置，通过成员函数insert将新值插入该位置，所有的容器都有该成员函数，所以，它适用于所有的标准容器
  * 当然，对于关联式容器，具体的插入位置取决于键或值
  * 同时，必须将insert的返回值赋给原来的迭代器变量pos，因为对于vector、deque和string，每一次插入操作都会使容器的所有迭代器失效

3）关联式容器的用户自定义插入型迭代器

- 对于关联式容器，指定错误的要插入的位置可能导致糟糕的性能
- 对于逆序插入，指定的插入位置就可能使程序变慢，因为程序总是从错误的位置开始查找真正的插入位置

3、流迭代器

- 输入流迭代器可以从输入流中读取元素，而输出流迭代器可以向输出流中写入元素
- 流迭代器的一种特殊形式是流缓冲区迭代器，用来对流缓冲区直接进行读写操作

1）输出流迭代器

- 输出流迭代器的实现机制和插入型迭代器一样，唯一的区别是执行赋值操作的operator =被转化为执行输出操作operator <<
- 构建输出流迭代器时，必须提供一个输出流作为参数，输出流迭代器会把元素输出到该流上

2）输入流迭代器

- 输入流迭代器是输出流迭代器的搭档，稍微复杂一些
- 构建输入流迭代器时，必须提供一个输入流作为参数，输入流迭代器会从该流中读取数据
- 读取操作有可能因为读到文件的尾部而失败，而且有些算法也需要知道是否到达文件的终点，因此，需要使用end-of-stream迭代器，这可以通过输入流迭代器的默认构造函数来构建

- 判断两个输入流迭代器相等的条件
  * 两个输入流迭代器都是end-of-stream迭代器，则它们是相等的
  * 两个输入流迭代器都还可以继续读取数据，并且它们指向同一个流，则它们是相等的

3）流迭代器的使用范例

- 示例程序使用了两种流迭代器，而且还使用了advance函数
  * advance函数用来帮助迭代器前进到另一个位置，当它和输入流迭代器配合工作时，效果就是跳过了一些输入记号
  * 在通过operator *访问其中的元素之前，一定要检查输入流迭代器是否仍然合法，否则会导致未定义的行为

五、迭代器特性

- 如果能根据不同的迭代器类别，对操作进行重载，这会很有用
- 通过迭代器标志和特性，可以实现这样的重载

- C++标准程序库为每一种迭代器提供了一个标志，作为迭代器的标签，比如output_iterator_tag
  * 这些标志之间存在继承关系，比如，forward_iterator_tag派生自input_iterator_tag，表示它是一种输入迭代器
  * 但 forward_iterator_tag并不派生自output_iterator_tag，所以它和输出迭代器无关

- 如果需要编写泛型代码，不仅需要了解迭代器的类别，还需要了解迭代器指向的元素的类型
- C++标准程序库提供了一种特殊的模板结构来定义迭代器特性，该结构包含和迭代器相关的所有信息，为迭代器的所有类型信息提供了统一的接口
- 这样的迭代器特性结构的两个优点
  * 能够确保每一种迭代器类别都提供必要的类型定义
  * 能够针对特定的迭代器进行特化

1、为迭代器编写泛型函数

- 通过迭代器特性，可以编写出泛型函数，根据迭代器类别来派生出新类型或者采用不同的具体实现

1）运用迭代器的类型

- 某个算法函数内部需要一个以容器的元素类型为类型的临时变量，那么就可以使用std::iterator_traits<T>::value_type来定义它

2）运用迭代器的类别

- 如果需要针对不同的迭代器类别采取不同的具体实现，可以按照下列步骤进行
  * 把迭代器的类别作为附加参数来调用另一个函数
  * 针对不同的迭代器类别实现出不同版本的另一个函数

3）distance的具体实现

- 根据前面所述的知识，实现出迭代器的辅助函数，distance
  * 对于随机存取迭代器，只需要进行减法运算就可以获得结果
  * 对于其他迭代器类别，必须一步一步前进才能计算出结果
- distance的返回值是迭代器的距离类型，difference_type

2、自定义的迭代器

- 如果需要自定义一个迭代器，就需要按照前面的方法为它提供特性
  * 一种方法是，提供iterator_traits结构要求的五种类型
  * 还有一种方法是，提供特化的iterator_traits结构
- 对于第一种方法，STL提供了一个特殊的基础类，std::iterator

- 示例程序展示了如何定义一个关联式容器的插入型迭代器
  * 类asso_insert_iterator从类iterator派生出来，第一个参数是output_iterator_tag，指明了迭代器的类型，由于这是一个输出迭代器，所以后续的四个参数都是void
  * 该迭代器将要操作的容器保存在成员变量container中，赋值操作都通过insert来将新值插入到该容器中，而operator *和operator ++都简单地返回*this，不做任何操作
  * 函数asso_inserter用来简化迭代器的创建和初始化，它返回一个插入型迭代器，可以直接对其赋值来完成插入操作

<2022-12-21>
