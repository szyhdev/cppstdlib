第五章 标准模板库

一、STL组件
二、容器
  1、序列式容器
    1）vector
    2）deque
    3）list
    4）string
    5）array
  2、关联式容器
  3、容器适配器
三、迭代器
  1、关联式容器的运用实例
    1）set和multiset运用实例
    2）map和multimap运用实例
    3）将map/multimap用作关联式数组
  2、迭代器分类
四、算法
  1、区间
  2、处理多个区间
五、迭代器适配器
  1、插入型迭代器
  2、流迭代器
  3、逆向迭代器
六、更易型算法
  1、删除元素
  2、更易型算法和关联式容器
  3、算法和成员函数
七、自定义的泛型函数
八、以函数作为算法的参数
  1、实例示范
  2、判断式
    1）一元判断式
    2）二元判断式
九、仿函数
  1、什么是仿函数
  2、预定义的仿函数
十、容器内的元素
  1、容器元素的条件
  2、值和引用
十一、STL内部的错误处理和异常处理
  1、错误处理
  2、异常处理
十二、扩展STL

- 标准模板库（Standard Template Library，STL）是C++标准程序库的核心
  * STL是一个泛型程序库，它的所有组件都由模板构成，其元素可以是任意类型
  * 从程序员的角度看，STL是由一些可适应不同需求的集合类型和一些可以被应用于这些集合类型的算法构成
  * 程序员还可以提供其它集合类型或算法，与现有的组件搭配工作
- 如此的灵活性并非免费午餐，代价总是有的，STL并不容易理解

- 本章介绍STL的总体概念
- 第六章到第九章详细讨论STL的各个组件，包括容器、迭代器、仿函数、算法等

一、STL组件

- STL的组件中最关键的部分是容器、迭代器和算法
  * 容器是用来管理某类对象的集合，每种容器都有自己的优点和缺点
  * 迭代器用来遍历一个集合的元素，它为所有的容器提供了一组很小的公共接口，每种容器都提供了自己的迭代器，它们知道如何在这种容器内迭代
  * 算法用来处理集合中的元素，包括搜寻、排序、修改等，和迭代器配合，算法可以被应用于任何容器

- STL的基本观念是将数据和操作分离
  * 数据由容器来管理，操作由算法来管理，迭代器则在二者之间充当粘合剂，使任何算法都可以被应用于任何集合
  * 从某种意义上说，这个观念和面向对象的最初思想是矛盾的，但其优点是，很容易将各种容器和各种算法相结合，在很小的框架内实现很大的弹性

- STL的一个根本特征是，所有组件都可以针对任意类型来运作，当然，前提是这些类型都能够执行必要的操作
- STL甚至还提供了更泛型化的组件，通过特定的适配器和仿函数来补充、约束或定制算法，以满足特殊的需求

二、容器

- 容器用来管理一组元素
- STL提供了不同类型的容器，包括vector、deque、list、set/multiset、map/multimap
- 总的来说，容器分为两类
  * 序列式容器：它是可序（ordered）集合，即，每个元素都有固定的位置，这取决于元素插入的时机和地点，这类容器包括vector、deque、list
  * 关联式容器 ：它是已序（sorted）集合，元素的位置取决于特定的排序规则，而和插入的时机和地点无关，这类容器包括set/multiset、map/multimap

- 关联式容器可以被看作特殊的序列式容器，因为它是按照某个排序规则来排列的
- 关联式容器自动对元素进行排序，但这并不意味着它们就是用来排序的，对序列式容器也可以进行排序
  * 自动排序的优点在于，搜寻元素时可以获得最佳的效率
  * 自动排序只不过是关联式容器的一个“副作用”而已

1、序列式容器

- STL提供了三种序列式容器，vector、deque、list
- 此外，string和array也可以被看作序列式容器

1）vector

- vector把元素放在一个动态数组中进行管理，允许随机存取，在尾部追加元素非常快速，但在首部或中部插入元素则比较费时
  * push_back用来在尾部追加元素，所有的序列式容器都提供该函数
  * size用来返回容器中的元素数量，所有的容器都提供该函数

2）deque

- deque也是一个动态数组，但它可以向两端发展，因此，在首部或尾部添加元素都很迅速，但在中部插入元素则比较费时
  * push_front用来在首部插入元素，而push_back用来在尾部添加元素
  * vector并未提供push_front函数，因为对于vector来说它的时间性能很差
- 一般来说，STL只提供具有良好时间性能的函数，即，具有常数复杂度或者对数复杂度的函数，这样可以防止程序员调用性能很差的函数

3）list

- list是以双向链表的形式实现的，每个元素都提供对前一元素和后一元素的引用，它不提供随机存取
- list的优势在于在任何位置上插入元素都很迅速，这意味着在中部插入元素会比vector和deque快得多
- empty检查容器中是否有元素，front返回第一个元素，而pop_front删除第一个元素
- list没有提供operator []，因为它对于list来说会导致不良的时间性能

4）string

- string和vector很像，只不过其元素是字符

5）array

- 严格讲，array并不是一种STL容器，它是C++语言核心支持的一种类型，没有类似size、empty这样的成员函数
- 不过，STL允许对array应用STL算法

2、关联式容器

- 关联式容器根据特定的排序规则自动为其元素排序
  * 排序规则以函数的形式提供，用来比较元素的值或者键
  * 缺省情况下通过operator <来进行比较
- 关联式容器通常是通过二叉树实现的
  * 每个元素都有一个父节点和两个子节点
  * 左子树的所有元素都比自己小，而右子树的所有元素都比自己大

- 关联式容器的差别在于元素的类型以及处理重复元素的方式
  * set按照元素的值排序，每个元素值只能出现一次
  * multiset和set相同，但允许重复元素
  * map的元素是键-值对，按照元素的键排序，每个键只能出现一次
  * multimap和map相同，但允许重复元素
- 所有的关联式容器都有一个可选的模板参数，用来指定排序规则，缺省是operator <，它也被用来测试相等性，即，如果两个元素都不小于对方，它们就是相等的
- set可以被看作是特殊的map，元素的键和值合二为一

3、容器适配器

- 除了上述容器之外，STL还提供了一些特别的容器适配器，它们是通过上述的基本容器来实现的
  * stack：以后进先出的方式管理元素
  * queue：以先进先出的方式管理元素
  * priority queue：按优先权来管理元素，优先权基于程序员提供的排序规则

三、迭代器

- 迭代器是一个可以遍历容器内部的元素的对象
- 一个迭代器指定了容器中的一个特定位置
- 迭代器的基本操作
  * operator *返回该位置上的元素的值
  * operator ++将迭代器前进到下一个元素
  * operator ==和operator !=判断两个迭代器是否相等或不相等
  * operator =为迭代器赋值

- 迭代器其实是个智能指针，具有遍历复杂数据结构的能力
  * 每一种容器都提供自己的迭代器，它通常是以嵌套类的形式提供的
  * 迭代器的接口相同，但应用的类型不同，这就是泛型设计的概念
- 所有的容器都提供一些成员函数来获得迭代器
  * begin返回一个迭代器，它指向容器的起点，即，第一个元素的位置
  * end返回一个迭代器，它指向容器的终点，即，最后一个元素之后的位置
  * begin和end共同组成了一个半开区间，左开放右封闭

- 任何一种容器都定义了两种迭代器类型，读写迭代器和只读迭代器，前者可以改变元素的值，而后者则不行
- 注意，使用前置式operator ++可以带来比后置式operator ++更好的性能

1、关联式容器的运用实例

1）set和multiset运用实例

- 缺省的排序规则以operator <为依据
- 如果需要使用不同的排序规则，就将它作为模板的第二个template参数传递给容器，比如greater<int>
- 所有的关联式容器都提供了insert成员函数来插入一个元素，该元素会根据排序规则插入到正确的位置
- 不允许针对关联式容器调用push_back或push_front，因为调用者无权决定元素被插入的位置
- 这里再次强调，由于迭代器是在容器的内部定义的，所以，不管容器的内部结构多么复杂，迭代器都知道如何遍历容器内的元素
- 如果需要使用multiset而不是set，只需要更改容器的名字即可，其他代码不变

2）map和multimap运用实例

- 和前面的set和multiset相比，map和multimap有以下两点不同
  * 元素是以键-值对的形式出现的，所以需要使用辅助函数make_pair
  * 迭代器取出的是键-值对，所以需要通过pair的成员first和second来分别获得键和值
- multimap可以被用作字典

3）将map/multimap用作关联式数组

- 如果一个map中的所有键-值对都是独一无二的，那么就可以把它用作一个关联数组
  * 通过operator []就可以访问其中的元素，键可以是任意的类型，这正是关联数组的接口，即，数组的索引可以是任意类型
  * 键可以不对应于现有的键，这样做会导致添加一个新的元素
- multimap不允许使用operator []，因为它允许同一个键对应多个元素

2、迭代器分类

- 迭代器被分为五种类型，输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机存取迭代器
- STL预定义的容器都属于后两种
  * 双向迭代器：可以双向前进，包括list、set/multiset、map/multimap
  * 随机存取迭代器：它具备了双向迭代器的全部能力，还具备了随机存取的能力，包括vector、deque、string、array

- 为了编写与容器类型无关的代码，最好不要使用随机存取迭代器的特有操作，比如operator <
- 不过，operator <比operator !=更安全，程序员可以根据具体情况做出取舍

四、算法

- 算法并非容器类型的成员函数，而是一种搭配迭代器使用的全局函数
  * 这样，一个算法就可以应用于所有类型的容器
  * 这是泛型函数式编程的思维模式，而不是面向对象的思维模式
- 示例程序中展示了min_element、max_element、sort、find、reverse等算法的应用

1、区间

- 所有的算法都是基于一个或多个区间进行处理的
  * 为了可以操作容器的某个子集，区间是通过首和尾两个参数来传递的
  * 这样的接口既灵活又危险，因为调用者必须确保区间是有效的，即，区间的首和尾属于同一个容器，并且前后顺序正确，否则会导致不可预料的后果
  * 所有算法处理的区间都是半开区间，即，左开放右封闭

- 对于双向迭代器，只能使用operator ++来前进迭代器，而对于随机存取迭代器，还可以使用operator +，因为它支持迭代器的算术运算
- 对于随机存取迭代器，还可以使用operator <来检查迭代器之间的前后关系，而对于非随机存取迭代器，则只能通过遍历来检查

2、处理多个区间

- 有的算法可以同时处理多个区间，对于第一个区间通常必须指明起点和终点，对于第二个区间则只需要指明起点，终点通过第一个区间推导出来
- 同时，在使用某个算法处理多个区间时，务必确保第二个区间的元素数量不少于第一个区间的元素数量

- 示例程序将第一个区间的所有元素复制到第二个目标区间，目标区间必须拥有足够的元素，否则复制操作就会导致未定义的行为
- 要保证目标区间够大，一种方法是一开始就给它设定一个正确的大小，另一种方法是显式地改变其大小，但这两种方法都只适用于序列式容器，对于关联式容器根本不存在这种问题，因为关联式容器不可能被用作复制算法的目标

五、迭代器适配器

- 迭代器是一个抽象概念，任何东西只要它的行为像迭代器，它就是一个迭代器
- C++标准程序库提供了一些预定义的特殊迭代器，即，迭代器适配器，包括插入型迭代器、流迭代器、逆向迭代器等

1、插入型迭代器

- 插入型迭代器可以使算法以插入而不是覆盖的形式添加元素，从而解决目标容器空间不足的问题
- 插入型迭代器对接口做了重新定义
  * 如果对容器的某个元素赋值，会引发插入操作，具体的插入位置视插入型迭代器的具体类型而定
  * operator ++不会引起任何操作

- 三种预定义的插入型迭代器
  * Back插入型迭代器：在内部调用push_back，将元素添加到容器的尾部，因此，只有在提供了成员函数push_back的容器上，它才能正常运作，这样的容器包括vector、deque、list
  * Front插入型迭代器：在内部调用push_front，将元素添加到容器的首部，因此，只有在提供了成员函数push_front的容器上，它才能正常运作，这样的容器包括deque、list
  * 一般性插入型迭代器：在内部调用insert，将元素插入到容器中指定的位置，因此，对于STL中的所有容器，它都能正常运作，注意，对于关联式容器来说，这个位置只是一个提示，并不一定是元素真正被插入的位置

2、流迭代器

- 另一种非常有用的迭代器适配器是流迭代器，它们使来自键盘的输入像是一个集合，可以从中读取数据
- 示例程序只用了三条语句就完成了从标准输入读取字符串、排序然后打印出来的工作
- 这个程序的所有组件都是基于模板的，很容易被重用于其他类型

3、逆向迭代器

- 第三种预定义的迭代器适配器是逆向迭代器，它以逆向的方式执行所有的操作，比如，operator ++其实执行的是递减运算
- 通过逆向迭代器，所有算法不需要特殊处理就可以以相反的方向处理容器内的元素
- 可以把普通的迭代器转换为逆向迭代器，不过，对于具体的迭代器而言，这种转换会改变它指向的对象

六、更易型算法

- 某些算法会更改目标区间中的内容，甚至删除元素，一旦这种情况出现，必须注意几个特殊问题

1、删除元素

- remove用来从某个区间删除元素，但它并不会改变容器中的元素数量，换句话说，在调用remove之后，end或size返回的仍然是原来的值
  * 不过，有些变化还是发生了，元素的顺序改变了，有些元素被覆盖了，还有些元素虽然仍然存在，但已经不属于这个容器了
  * remove返回一个迭代器，这个迭代器才是容器的最新的终点，利用它可以获得容器的区间或者计算被删除的元素的数量

- 如果希望把某个区间内的元素彻底删除，需要调用erase
  * remove并没有自动调用erase，原因是这些通过迭代器操作容器元素的算法对容器知之甚少，无法通过迭代器访问容器的成员函数
  * 另外，有些容器可能并不提供erase，比如array，所以，不要求迭代器了解容器的细节还是有道理的

2、更易型算法和关联式容器

- 更易型算法不能被用于关联式容器，因为一旦某个元素被改变了，就破坏了关联式容器的排序规则
- 为了保持这个排序规则，关联式容器的所有迭代器均被声明为常量
- 要从关联式容器中删除元素，需要调用其成员函数

3、算法和成员函数

- 有时候容器本身提供的成员函数的性能比算法更好
  * 算法并不知道自己工作在list上，在删除一个元素后，它会采用通用的方法把元素依次用其后的元素覆盖，但list可以通过修改链接来快速删除元素的优点就被忽略了
  * 直接调用list的成员函数remove会获得更好的性能

- 如果高性能是最高目标，应该永远优先使用成员函数
- 针对list使用remove算法并不会收到任何警告信息，而调用list的成员函数remove在更换容器类型时则不得不修改代码，程序员需要做出权衡

七、自定义的泛型函数

- STL是一个可扩展的框架，程序员可以实现自己的函数和算法来处理容器内的元素
- 为了在这些函数和算法中有效地使用迭代器，必须使用容器提供的迭代器类型，因为每种容器都有自己的迭代器
- 注意，在算法中使用容器的迭代器类型时，必须使用typename关键字来告诉编译器它是一个类型，而不是一个值
- 除了iterator和const_iterator之外，容器还可以提供其他类型，比如，value_type，以帮助实现自定义的泛型函数

八、以函数作为算法的参数

- 一些算法可以接受用户自定义的辅助函数，由此来提高灵活性和能力，这些函数会在算法内部被调用

1、实例示范

- 最简单的例子莫过于for_each了
- 对于有的算法，这种辅助函数是可有可无的，而对于有的算法，它们是必要的
- 这些辅助函数可以被用来指定查找规则、排序规则或者定义某种操作

2、判断式

- 有一种特殊的辅助函数是判断式，其实就是返回布尔值的函数，通常被用来指定查找规则或排序规则
- 判断式通常具有一个或两个操作数，视具体情形而定
- 不过，并非返回布尔值的一元或二元函数都是合法的判断式，STL要求，面对同样的值，判断式必须返回同样的结果，这条规则把那些调用时会改变自己内部状态的函数排除在外了

1）一元判断式

- 一元判断式一般会检查唯一的一个参数的某个特性
- 示例程序中的isPrime用来检查某个数是否是素数

2）二元判断式

- 二元判断式的典型应用是，比较两个参数的某个特性
- 如果元素不支持operator <，或者需要定义自己的排序规则，二元判断式就派上用场了
- 当然，也可以使用仿函数作为排序规则，它的优点是，排序规则以一个类型的形式出现

九、仿函数

- 作为参数传递给算法的函数也可以是类似函数的对象，这种对象被称为“仿函数”

1、什么是仿函数

- 仿函数是泛型编程的强大威力和纯粹抽象的又一个例证，即，任何东西只要它的行为像函数，它就是个函数
- 所谓的“函数行为”就是可以通过圆括号传递参数并调用的行为
- 对于C++，只需要定义operator ()，并设置合适的参数即可

- 和普通函数相比，仿函数有以下优点
  * 仿函数是智能函数，它可以拥有成员函数和成员变量，这意味着仿函数可以具有状态，而且可以在运行期设置状态
  * 每个仿函数都有自己的类型，这对利用模板实现泛型编程是一个贡献，函数行为由此可以被当作模板参数来使用，不同类型的仿函数就定义了不同的排序规则
  * 仿函数通常比普通函数更快，因为很多细节已经在编译期被确定，所以可以进行更好的优化

- 示例程序一展示了利用模板参数为容器中的每一个元素增加一个固定值的实现方法
- 示例程序二展示了利用仿函数的状态为容器中的每一个元素增加一个可变值的实现方法
- 需要注意的是，C++标准程序库并没有限制算法对容器中的元素调用仿函数的次数，这可能导致仿函数的多个副本被应用到元素上，这有时候会带来麻烦，比如，把仿函数用作判断式时

2、预定义的仿函数

- C++标准程序库提供了一些预定义的仿函数，包括less、greater、negate、multiplies等
- 通过一些特殊的函数适配器，还可以将预定义的仿函数和其他数值组合在一起
  * transform期望它的最后一个参数是接受单一参数的表达式，但这里需要首先把该单一参数和10相乘
  * bind2nd会把10作为第二个参数保存下来，然后把容器的元素作为第一个参数与第二个参数相乘，并返回结果
- 这种方式可以用于很多类似的情形
  * bind2nd(equal_to<int>, 70)表示“等于70”的排序规则
  * bind2nd(less<int>, 50)表示“小于50”的排序规则
- 通常，所有的仿函数都被声明为inline，因此，一方面可以获得类似函数的抽象性，另一方面又能获得出色的性能
- 另外，还有一些仿函数可以调用容器中的元素的成员函数，比如，mem_fun_ref(&Person::save)，当然，前提是这些元素的类型是Person

十、容器内的元素

- 容器内的元素必须符合一定的条件，因为容器会以一种特别的方式来操作它们
- 此外，容器还需要对其元素进行复制

1、容器元素的条件

- STL的容器、迭代器和算法都是基于模板的，可以操作任意的类型
- STL容器中的元素必须满足三个基本要求
  * 通过拷贝构造函数进行复制
  * 通过赋值操作符进行赋值
  * 通过析构函数进行销毁
- 这三个操作对任何类型来说都是隐式成立的，除非它定义了自己的特殊版本

- 对于序列式容器而言，元素的缺省构造函数必须是可用的
- 对于某些操作，必须定义operator ==来测试相等性
- 对于关联式容器而言，元素必须提供operator <，以便定义出排序规则，该操作符是通过仿函数less被调用的

2、值和引用

- 所有的容器都会创建元素的副本，这意味着容器内的元素和传入的元素相等，但并非同一个元素
  * 所以，容器提供的是值语义
  * 这样做的好处是元素的复制很简单，如果使用引用，复制操作很容易导致错误，坏处是复制元素使性能下降，有时甚至无法复制，并且无法在多个容器中管理同一个对象

- 实际情况下，这两种语义都有价值，因此，可以利用值语义来实现引用语义
- 一种显而易见的方法是，使用指针作为元素，这会遇到一些常见问题，比如，指针指向的对象可能已经不复存在或者比较行为不符合预期
- 更好一点儿的办法是，使用智能指针，但这也有一些问题，而且，千万不要使用auto_ptr，因为它不满足容器对元素的基本要求

十一、STL内部的错误处理和异常处理

1、错误处理

- STL的设计原则是效率优先，安全次之，因此它几乎没有错误处理
- 这样做的两个原因
  * 错误检查会降低效率，而速度才是STL的首要目标
  * 如果需要更安全的检查，可以通过添加一层包装或者使用STL的特殊版本来实现
- C++标准程序库指出，如果对STL的任何运用违反了规则，将会导致未定义的行为，从这个意义上说，STL和C指针一样容易引起错误

- 使用STL必须满足以下要求
  * 迭代器必须合法有效，这意味着在使用它们之前必须初始化，而且要注意对容器的更易性操作会导致它们变为无效
  * 一个指向容器的终点的迭代器并不指向任何元素，不能对它调用operator *或者operator ->
  * 区间必须是合法的，用于区间的两个迭代器必须属于同一个容器，而且从第一个迭代器出发可以到达第二个迭代器
  * 如果算法涉及多个区间，后续区间的元素不得少于第一个区间的元素
  * 覆盖操作中的目标区间必须拥有足够的可覆盖的元素，否则就需要使用插入型迭代器

- 因此，在开发阶段使用安全版本的STL是一个好主意
- 大部分STL都是基于STL的原始版本，不过，有一个带有警告能力的STL版本，STLport，几乎可以用于任何平台

2、异常处理

- STL不检查逻辑错误，所以，逻辑问题不会引发异常
  * C++标准只要求唯一的一个函数在必要时必须引发异常，vector和deque的at
  * 此外，C++标准要求只有一般的异常才可以发生，比如，内存不足引发的bad_alloc
- 因此，异常一旦发生，STL基本上无能为力，甚至不能正确完成栈展开

- 对于异常处理，找到好的解决方法并不容易
  * 很难确定C++标准程序库到底需要什么样的安全程度，安全程度的提升可能导致很大的性能损失
  * 处理异常的程序代码本身也会给性能带来负面影响，这与“尽可能获得最佳性能”的设计目标相抵触
- 于是，C++标准程序库就异常处理问题做出的基本保证是，在异常发生时，既不会发生资源泄露，也不会导致容器的恒常性的丧失

- 但这远远不够，还需要保证正在进行的操作的安全性，数据库领域的术语称之为“事务安全”
- 考虑到这种要求，C++标准程序库如今做出以下两个保证
- 第一个保证：对于所有以节点为实现基础的容器
  * 如果节点构造失败，则容器保持不变
  * 删除元素的操作保证不会失败
  * 对关联式容器插入单一元素，要么成功，要么没有任何影响，但如果是插入多个元素，失败时无法恢复原状
  * 对于擦除操作，一定会成功
  * 对于list，即使是插入多个元素，该操作也是事务安全的
  * 事实上，对于list的所有操作，除了remove、remove_if、merge、sort、unique之外，要么成功，要么没有任何影响，所以，如果需要一个事务安全的容器，就应该选择list
- 第二个保证：对于所有以数组为实现基础的容器
  * 插入元素时如果失败，则无法完全恢复原状，因为这个代价很大
  * push和pop这两个操作由于是在容器的尾部进行，失败时可以恢复原状
  * 如果元素的类型能够保证拷贝构造函数和赋值操作符不抛出异常，则相关的操作也可以保证“要么成功，要么没有任何影响”的行为
- 以上两个保证都基于一个前提，析构函数不能抛出异常

十二、扩展STL

- STL被设计为一个框架，可以进行扩展
- 程序员可以提供自己的容器、迭代器、算法、仿函数等，只要满足必备的条件即可
- STL遗漏的最重要的组件是哈希表，新的标准程序库可能会包含它们，事实上，大部分现有的C++标准程序库已经提供了哈希表，但彼此之间存在差异

<2022-11-30>
