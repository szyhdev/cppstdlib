第九章 算法

一、算法头文件
二、算法概览
  1、简介
  2、算法分门别类
    1）非变动性算法
    2）变动性算法
    3）移除性算法
    4）变序性算法
    5）排序算法
    6）已序区间算法
    7）数值算法
三、辅助函数
四、for_each算法
五、非变动性算法
  1、元素计数
  2、最小值和最大值
  3、查找元素
    1）查找第一个匹配元素
    2）查找前n个连续的匹配值
    3）查找第一个子区间
    4）查找最后一个子区间
    5）查找某些元素第一次出现的地点
    6）查找两个连续且相等的元素
  4、区间的比较
    1）检验相等性
    2）查找第一个不同点
    3）检验“小于”关系
六、变动性算法
  1、复制元素
  2、转换和组合元素
    1）转换元素
    2）组合两个序列的元素
  3、互换元素内容
  4、赋予新值
    1）赋予完全相同的数值
    2）赋予新产生的数值
  5、替换元素
    1）替换序列内的元素
    2）复制并替换元素
七、移除性算法
  1、移除特定元素
    1）移除序列内的元素
    2）复制并移除元素
  2、移除重复元素
    1）移除连续的重复元素
    2）复制并移除重复元素
八、变序性算法
  1、逆转元素顺序
  2、旋转元素顺序
    1）旋转序列内的元素
    2）复制并旋转元素
  3、排列元素
  4、重排元素
  5、将元素向前移动
九、排序算法
  1、对所有元素排序
  2、局部排序
  3、根据第n个元素排序
  4、堆算法
    1）细节
    2）范例
十、已序区间算法
  1、查找元素
    1）检查某个元素是否存在
    2）检查若干个值是否存在
    3）查找第一个或最后一个可能的位置
    4）查找第一个和最后一个可能的位置
  2、合并元素
    1）两个已序集合的总和
    2）两个已序集合的并集
    3）两个已序集合的交集
    4）两个已序集合的差集
    5）合并连贯的已序集合
十一、数值算法
  1、加工运算后产生结果
    1）对序列进行某种运算
    2）计算两个序列的内积
  2、相对值和绝对值之间的转换
    1）将相对值转换为绝对值
    2）将绝对值转换为相对值
    3）相对值转换为绝对值的示例

- 本章描述C++标准程序库提供的所有算法
  * 首先，对所有算法及其主要特征进行概述
  * 然后，展示每一种算法的确切形式，并通过一个或多个示例来说明其用法

一、算法头文件

- 要使用C++标准程序库的算法，需要包含头文件<algorithm>，该头文件包含一些辅助函数，比如，min、max、swap等
- 某些算法用于数值处理，被定义在头文件<numeric>中
- 使用算法时常常需要用到仿函数和函数适配器，它们都被定义在头文件<functional>中

二、算法概览

- 本章概述C++标准程序库中的所有算法，在遇到问题时可以选择最适用的算法

1、简介

- 所有的STL算法都被设计来处理一个或多个迭代器区间
  * 第一个区间通常通过起点和终点来表示
  * 其他区间多数情况下只需要提供起点即可，终点可以根据第一个区间推导出来
- 调用者必须保证这些区间的有效性，包括区间的起点和终点必须指向同一个容器、起点的位置不能位于终点的位置之后、第二个区间必须具有足够的空间等

- STL算法采用覆盖模式而不是插入模式，因此，调用者必须保证目标区间具有足够的元素空间
- 当然，也可以使用特殊的插入型迭代器来将覆盖模式变为插入模式

- 为了提高灵活性，某些算法允许调用者传递自定义的操作，由算法来调用
  * 这些操作可以是一般函数，也可以是仿函数
  * 如果其返回值为bool，则被称为“判断式”
- 判断式可以被用于完成以下工作
  * 作为查找算法的查找规则
  * 作为排序算法的排序规则
  * 作为某个元素是否应该参与某个运算的判断规则
  * 为某个数值算法指定一个数值运算
- 注意，判断式不应该在函数调用过程中改变其自身的状态

2、算法分门别类

- 不同的算法满足不同的需求，可以根据它们的目的加以分类
- 为了让人可以顾名思义，算法的命名引入了两个特别的后缀
  * _if：没有_if后缀的算法要求传递一个数值，而有_if后缀的算法要求传递一个函数或仿函数，当然，并非所有要求传递一个函数或仿函数的算法都带有后缀_if
  * _copy：这个后缀表明元素在该算法中不仅会被操作，而且会被复制到目标区间

- 后续章节按照以下分类方法来描述STL的算法，包括非变动性算法、变动性算法、移除性算法、变序性算法、排序算法、已序区间算法、数值算法
- 有的算法同时隶属于多个分类，会被放在最贴切的分类中讲述

1）非变动性算法

- 非变动性算法不改变元素的顺序，也不改动元素的值，它们通过输入迭代器和前向迭代器来完成工作，因此可以被用于所有的容器
- 常用的非变动性算法包括for_each、count、count_if、min_element、max_element、find、find_if、search_n、search、find_end、find_first_of、adjacent_find、equal、mismatch、lexicographical_compare
- 还有一些非变动性算法专门用来操作已序区间

- 最重要的算法之一是for_each，它将调用者提供的一个操作施加在每个元素上
- for_each也可以用来变动元素，但如果存在其他算法满足同样的需求，应该避免使用for_each，毕竟其他算法是为特定任务量身定做的

- 很多非变动性算法具有查找能力，但它们的命名方式却一团混乱，而且和string的查找函数的命名差别很大，这是由一些历史原因导致的
  * STL和string是各自独立发展和设计的
  * find_end、find_first_of、search_n等算法并没有包括在早期的STL中，比如，find_end本应是search_end，但一旦深入到细节，像“一致性”这样的大局观问题就很容易会被忽略

2）变动性算法

- 变动性算法要么直接改变元素的值，要么在将元素复制到另一个区间的过程中改变元素的值
- 常用的变动性算法包括for_each、copy、copy_backward、transform、merge、swap_ranges、fill、fill_n、generate、generate_n、replace、replace_if、replace_copy、replace_copy_if

- 最基本的变动性算法是for_each和transform
  * for_each接受一个操作，该操作可以变动参数，这需要将元素的值以引用方式作为参数来传递
  * transform执行一个操作，该操作接收元素的值作为参数、返回改动后的值并赋给原来的元素
- transform的速度稍慢，因为它不是直接修改元素的值，而是把返回值赋给元素

- 严格地说，merge不算是变动性算法的一员，因为它要求输入区间必须是已序的，所以，应该归类于已序区间算法
  * 不过，merge也可以用来合并无序区间，当然结果也是无序的
  * 出于安全的考虑，最好只对已序区间使用merge

- 关联式容器的元素被视为常量，所以，不能将关联式容器的区间作为变动性算法的目标区间
- 除了上述这些变动性算法，C++标准程序库还提供了不少专门用来处理已序区间的算法

3）移除性算法

- 移除性算法是一种特殊的变动性算法，它可以移除某个区间内的元素，也可以在复制过程中执行移除操作
- 常用的移除性算法包括remove、remove_if、remove_copy、remove_copy_if、unique、unique_copy
- 和变动性算法类似，移除性算法的目标区间也不能是关联式容器

- 注意，移除性算法只是在逻辑上移除元素，即，将不需要移除的元素向前移动覆盖掉需要移除的元素
- 因此，它们不会改变操作区间内元素的数目，而是返回逻辑上的新的终点位置，是否需要使用这个位置是调用者的事情

4）变序性算法

- 变序性算法通过对元素进行赋值或交换来改变元素的顺序，但它们并不改变元素的值
- 常用的变序性算法包括reverse、reverse_copy、rotate、rotate_copy、next_permutation、prev_permutation、random_shuffle、partition、stable_partition
- 和变动性算法类似，变序性算法的目标区间也不能是关联式容器

5）排序算法

- 排序算法是一种特殊的变序性算法，它们比一般的变序性算法更复杂，需要花费更多的时间
- 事实上，排序算法的复杂度通常低于线性复杂度，而且需要使用随机存取迭代器
- 常用的排序算法包括sort、stable_sort、partial_sort、partial_sort_copy、nth_element、partition、stable_partition、make_heap、push_heap、pop_heap、sort_heap

- 对于排序算法而言，时间往往非常重要，所以，C++标准程序库提供了多个排序算法
  * sort：采用快速排序算法，具有很好的平均性能，复杂度为O(n * log(n))，在最差的情况下可能具有二次复杂度，如果需要避免最差的情况，就应该采用其他算法，比如，partial_sort或stable_sort
  * partial_sort：采用堆排序算法，优点是在任何情况下都可以保持O(n * log(n))的复杂度，在大多数情况下比快速排序的速度慢2~5倍，所以，尽管partial_sort具有更好的复杂度，但sort具有更好的执行效率，partial_sort的特点是，可以只对前n个元素进行排序，完成后就立刻停止
  * stable_sort：采用合并排序算法，在内存充足时具有O(n * log(n))的复杂度，否则具有O(n * log(n) * log(n))的复杂度，它的优点是可以保持相等元素之间的相对顺序不变

- C++标准规格书没有规定排序算法的具体实现方法
  * 优点是，任何具体的实现版本都可以在不违反标准的前提下，采用新发明的、更好的排序算法，比如，SGI的sort版本采用的是一种新算法，introsort，默认情况下类似于quicksort，一旦遇到最差情况就会转而采用heapsort以避免达到二次复杂度
  * 缺点是，有些实现版本可能会采用符合标准但性能很糟糕的排序算法
- 可以通过实际的测试来选择哪个排序算法更符合要求，但这种测试一般不具有可移植性

- 还有其他排序算法
  * heap算法中有一个函数，make_heap，可以实现一个二叉树用来排序
  * heap算法是priority queue的实现基础

- 如果只需要排序后的第n个元素，或者只需要对最先或最后的n个元素进行排序，可以使用nth_element
- nth_element可以将元素按照某种排序规则分为两个子集，不过，partition和stable_partition也能达到相同的效果
  * nth_element：传入的是第一个子集的元素数目，不过，最后得到的两个子集都可能包含与第n个元素相等的元素
  * partition：传入的是将第一个子集和第二个子集区分开来的排序规则，返回的pos指明了第二个子集的起点位置，第二个子集保证都不满足该排序规则
  * stable_partition：和partition类似，不过它还可以保证两个子集内的元素的相对顺序在排序前后保持不变

- 对于所有的排序算法，排序规则都是可有可无的参数，缺省的排序规则是仿函数less，所以，元素会按照升序排列
- 和变动性算法类似，排序算法的目标区间也不能是关联式容器
- list没有提供随机存取迭代器，所以，不能对它使用排序算法，但list本身提供了一个sort成员函数，可以用来对元素进行排序

6）已序区间算法

- 已序区间算法是指应用算法的区间已经是通过某种排序算法排序的
- 常用的已序区间算法包括binary_search、includes、lower_bound、upper_bound、equal_range、merge、set_union、set_intersection、set_difference、set_symmetric_difference、inplace_merge
- 其中，前五个算法属于非变动性算法，它们只查找元素，其他的算法则用来将两个已序区间组合起来

7）数值算法

- 数值算法以不同的方式组合数值元素
- 常用的数值算法包括accumulate、inner_product、adjacent_difference、partial_sum
- 其中，前两个算法返回一个值，但不会变动区间，其他的算法会将结果写到目标区间中

三、辅助函数

- 为了简化后续章节中的例子，这里定义了一些辅助函数
  * algostuff.h中包含了可能用到的头文件
  * 此外，它还定义了两个辅助函数，PRINT_ELEMENTS和INSERT_ELEMENTS

四、for_each算法

- for_each算法非常灵活，它可以以不同的方式存取、处理或修改每一个元素
  * for_each对区间内的每一个元素调用一个操作，并返回该操作的一个副本，即，该操作已经在算法内部发生变动
  * 该操作的返回值会被忽略，这是for_each和transform不同的地方
- 复杂度：线性，执行操作numberOfElements次

- 示例程序一对每个元素调用print将其输出，如果想要调用元素的成员函数，可以使用mem_fun
- 示例程序二通过一个仿函数改变元素的内容，这样做的好处是，可以在运行时传入需要增加的数值，不过，同样的功能也可以通过transform来完成
- 示例程序三展示了如何利用for_each的返回值来传递信息

五、非变动性算法

- 非变动性算法不会改变元素的值，也不会改变元素的顺序

1、元素计数

- count：计算指定区间中等于指定值的元素的数目
- count_if：计算指定区间中满足一元判断式条件的元素的数目
- 注意，一元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 关联式容器提供了一个等效的成员函数，count，用来计算等于某个键或某个值的元素的数目
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序根据不同的比较准则来对元素进行计数，其中，isEven函数也可以替换为not1(bind2nd(modulus<int>(), 2))

2、最小值和最大值

- min_element：返回指定区间中的最小元素的位置，第一种形式按照operator <来进行比较，第二种形式按照指定的比较操作来进行比较
- max_element：返回指定区间中的最大元素的位置，第一种形式按照operator <来进行比较，第二种形式按照指定的比较操作来进行比较
- 注意，比较操作不应该改动传入的参数
- 复杂度：线性，执行比较操作numberOfElements - 1次

- 示例程序使用min_element和max_element打印出序列中的最大元素和最小元素，absLess用来对元素的绝对值进行比较，通过它可以打印出具有最大和最小绝对值的元素的值

3、查找元素

1）查找第一个匹配元素

- find：查找指定区间中第一个等于指定值的元素的位置
- find_if：查找指定区间中第一个满足一元判断式条件的元素的位置
- 注意，一元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 如果是已序区间，应该使用lower_bound、upper_bound、equal_range、binary_search来获得更好的性能
- 关联式容器提供了一个等效的成员函数，find，可以提供对数复杂度，而不是线性复杂度
- 复杂度：线性，最多执行比较操作numberOfElements次

- 示例程序一使用find查找一个子区间
  * 从值等于4的第一个元素开始，到值等于4的最后一个元素结束
  * 注意，在使用find的返回值之前，最好先对其进行检查以避免未定义的行为
- 示例程序二使用find_if按照某种规则来查找特定的元素
  * 一个规则是bind2nd(greater<int>(), 3)，用来查找大于3的元素
  * 另一个规则是not1(bind2nd(modulus<int>(), 3))，用来查找能被3整除的元素

2）查找前n个连续的匹配值

- search_n：第一种形式返回指定区间中第一组连续n个元素的值都等于指定值的元素的位置
- search_n：第二种形式返回指定区间中第一组连续n个元素的值都满足二元判断式条件的元素的位置
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 注意，这两个算法并不在早期的STL规范中，因此，第二种形式使用了一个二元判断式，这破坏了早期STL的一致性
- 复杂度：线性，最多执行比较操作numberOfElements * count次

- 示例程序展示了search_n的用法
  * 首先查找连续4个等于3的元素，然后查找连续4个大于3的元素
  * 注意，对于search_n的第二种形式，在实际上只需要一个一元判断式的情况下，它使用了一个二元判断式，必要时需要对已有的一元判断式进行包装，以满足算法对二元判断式的要求

3）查找第一个子区间

- search的两种形式都返回区间[begin, end)中和区间[searchBegin， searchEnd)相吻合的第一个子区间的第一个元素的位置
  * 第一种形式中，两个区间的元素必须完全相等
  * 第二种形式中，两个区间的元素必须满足二元判断式条件
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 复杂度：线性，最多执行比较操作numberOfElements * numberOfSearchElements次

- 示例程序一在一个序列中查找一个子序列，两个序列中的元素必须一一相等
- 示例程序二在一个序列中按照更复杂的查找规则来查找一个子序列，它必须符合“偶数、奇数、偶数”的规则

4）查找最后一个子区间

- find_end的两种形式都返回区间[begin, end)中和区间[searchBegin， searchEnd)相吻合的最后一个子区间的第一个元素的位置
  * 第一种形式中，两个区间的元素必须完全相等
  * 第二种形式中，两个区间的元素必须满足二元判断式条件
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 这些算法不是早期STL的一部分，如果命名为search_end，会比较具有一致性
- 复杂度：线性，最多执行比较操作numberOfElements * numberOfSearchElements次

- 示例程序展示了在一个序列中查找与某个子序列一一相等的最后一个子序列

5）查找某些元素第一次出现的地点

- find_first_of：第一种形式返回第一个既在[beg, end)中出现，又在[searchBeg, searchEnd)中出现的元素在[beg, end)中的位置
- find_first_of：第二种形式返回第一个在[beg, end)中的能够和[searchBeg, searchEnd)中的元素满足二元判断式条件的元素在[beg, end)中的位置
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 使用逆向迭代器可以搜索最后一个这样的元素
- 这些算法不在早期的STL规范中，所以，也不具有一致性
- 复杂度：线性，最多执行比较操作numberOfElements * numberOfSearchElements次

- 示例程序展示了find_first_of的用法
  * 第二次调用find_first_of采用了逆向迭代器
  * 为了打印这个元素的位置，可以先使用base将逆向迭代器转换为一般的正向迭代器，然后再使用distance来进行计算

6）查找两个连续且相等的元素

- adjacent_find：第一种形式返回区间中第一对连续的、相等的元素中的第一个元素的位置
- adjacent_find：第二种形式返回区间中第一对连续的、满足二元判断式条件的元素中的第一个元素的位置
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 复杂度：线性，最多执行比较操作numberOfElements次

- 示例程序展示了adjacent_find的两种形式的用法
  * 第一次调用是为了查找连续的相等值
  * 第二次调用以doubled函数作为比较规则来查找符合条件的连续值

4、区间的比较

1）检验相等性

- equal：第一种形式判断两个区间中的对应元素是否相等
- equal：第二种形式判断两个区间中的对应元素是否满足二元判断式条件
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 当序列不相等时，可以通过mismatch来找出它们之间的不同
- 复杂度：线性，最多执行比较操作numberOfElements次

- 示例程序展示了equal的两种形式的用法
  * 第一次调用检查两个区间的元素是否相等
  * 第二次调用检查两个区间的元素是否具有一一对应的奇偶关系

2）查找第一个不同点

- mismatch：第一种形式返回两个区间中第一对两两不相等的元素
- mismatch：第二种形式返回两个区间中第一对不满足二元判断式条件的元素
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 如果想知道两个区间是否相等，应该使用equal
- 复杂度：线性，最多执行比较操作numberOfElements次

- 示例程序展示了mismatch的两种形式的用法
  * 第一次调用查找第一对两两不同的元素的位置
  * 第二次调用查找第一对这样的元素的位置，第一个区间中的元素比第二个区间中的元素大

3）检验“小于”关系

- lexicographical_compare的两种形式都用来判断第一个区间中的元素是否都小于第二个区间的元素，这里的“小于”是按照字典顺序来判断的
  * 第一种形式使用operator <来进行比较
  * 第二种形式使用一个二元判断式来进行比较
- 注意，二元判断式在执行过程中不应该改变自身的状态，而且，不应该改动传入的参数
- 复杂度：线性，最多执行比较操作2 * min(numberOfElements1, numberOfElements2)次

- 示例程序展示了如何利用lexicographical_compare来对一个vector按照字典顺序进行排序
  * vector中的每个元素都是一个list
  * lessForCollection函数用来比较两个list，list之间的比较操作是通过调用lexicographical_compare来实现的

六、变动性算法

- 两种变动元素内容的方法
  * 在使用迭代器遍历序列的过程中，直接修改元素
  * 在将元素从源区间复制到目标区间的过程中进行变动
- 注意，目标区间不能是关联式容器，因为关联式容器的元素被视为常量，如果没有这个限制，自动排序的特性将无法得到保证
- 所有具有单一区间的算法，都返回区间中最后一个被复制的元素的下一个位置

1、复制元素

- copy：将源区间的所有元素复制到destBeg指定的目标区间中
- copy_backward：将源区间的所有元素复制到destEnd指定的目标区间中
- destBeg或者destEnd不能位于[sourceBeg, sourceEnd)中
- copy正向遍历序列，而copy_backward逆向遍历序列，只有在源区间和目标区间出现重叠时，才需要考虑它们之间的不同
  * 如果需要把一个区间复制到前端，应该使用copy，这样destBeg位于sourceBeg之前
  * 如果需要把一个区间复制到后端，应该使用copy_backward，这样destEnd位于sourceEnd之后
  * 也就是说，当第三个参数位于源区间中时，就应该使用另外那种形式
- 没有所谓的copy_if，如果需要复制符合特定规则的元素，就应该使用remove_copy_if
- 如果需要在复制过程中逆转元素顺序，就应该使用reverse_copy
- 如果要把容器内的所有元素都赋给另一个容器，就应该使用赋值操作符（当两个容器的类型相同时）或者assign成员函数（当两个容器的类型不同时）
- 如果需要在复制过程中删除某些元素，就应该使用算法remove_copy或remove_copy_if
- 如果需要在复制过程中改变元素，就应该使用transform
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 复杂度：线性，执行操作numberOfElements次

- 示例程序一展示了插入型迭代器的用法
  * Back插入型迭代器用来在目标区间中插入元素，否则，copy会在目标区间上执行覆盖操作，导致未定义的行为
  * ostrteam_iterator用来在标准输出中插入元素
- 示例程序二中，不管是copy还是copy_backward，它们的第三个参数都没有位于源区间中
- 示例程序三展示了如何使用copy作为标准输入和标准输出之间的数据过滤器，它从命令行读取字符串，然后逐行输出

2、转换和组合元素

- transform的两种形式
  * 第一种形式把源区间的元素转换到目标区间中，复制和修改都被执行
  * 第二种形式将两个序列中的元素合并，并将结果写入目标区间

1）转换元素

- transform的第一种形式对源区间中的每一个元素执行操作，并将结果写入目标区间的对应位置
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间和源区间可以相同，所以，和for_each一样，该算法可以用来变动某一序列内的元素
- 如果想用某个值替换符合某一规则的元素，应该使用replace
- 复杂度：线性，执行操作numberOfElements次

- 示例程序展示了如何转换源区间的每一个元素，并将结果写入目标区间

2）组合两个序列的元素

- transform的第二种形式对第一个源区间和第二个源区间的每一个元素执行操作，并将结果写入目标区间的对应位置
- 调用者必须保证第二个源区间有足够的空间
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间和两个源区间都可以相同，两个源区间相同相当于让元素自己和自己组合
- 复杂度：线性，执行操作numberOfElements次

- 示例程序展示了如何对两个序列的指定元素进行处理，并将结果写入目标区间中

3、互换元素内容

- swap_ranges：将第一个区间和第二个区间的元素互换，注意，两个区间不能重叠
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 如果是互换两个类型相同的容器的全部元素，就应该使用swap成员函数，因为该成员函数通常具有常数复杂度
- 复杂度：线性，执行操作numberOfElements次

- 示例程序展示了swap_ranges的用法
  * 第一次调用将序列一中的元素与序列二中的对应元素互换，序列二中的其他元素保持不变
  * 第二次调用将序列二中的前三个元素和后三个元素互换，由于使用了逆向迭代器，这些元素以镜像的方式进行互换

4、赋予新值

1）赋予完全相同的数值

- fill：将指定区间中的每一个元素都赋予一个指定值
- fill_n：将指定位置开始的前n个元素都赋予一个指定值
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 复杂度：线性，执行操作numberOfElements或者num次

- 示例程序展示了fill和fill_n的用法
  * 第一次调用展示了如何使用fill_n来输出特定数目的值
  * 后续的调用展示了如何使用fill和fill_n在list中插入元素

2）赋予新产生的数值

- generate：将指定区间中的每一个元素都赋予一个指定操作返回的值
- generate_n：将指定位置开始的前n个元素都赋予一个指定操作返回的值
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 复杂度：线性，执行操作numberOfElements或者num次

- 示例程序展示了如何使用generate和generate_n在list中插入元素

5、替换元素

1）替换序列内的元素

- replace：将指定区间中的等于指定值的每一个元素替换为新值
- replace_if：将指定区间中的满足一元判断式条件的每一个元素替换为新值
- 注意，一元判断式在执行过程中不应该改变自身的状态
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了replace和replace_if的用法

2）复制并替换元素

- replace_copy：将指定区间中每一个元素复制到目标区间中，然后将其中等于指定值的每一个元素替换为新值，相当于copy和replace的组合
- replace_copy_if：将指定区间中每一个元素复制到目标区间中，然后将其中满足一元判断式条件的每一个元素替换为新值，相当于copy和replace_if的组合
- 注意，一元判断式在执行过程中不应该改变自身的状态
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了replace_copy和replace_copy_if的用法

七、移除性算法

- 移除性算法根据元素的值或者某种规则，从一个区间中移除元素
  * 这些算法并不会改变元素的数目，而是从逻辑上将原来位于后面的不需要移除的元素向前移动以覆盖掉需要移除的元素
  * 它们都会返回新区间的终点位置，即，最后一个不需要移除的元素的下一个位置

1、移除特定元素

1）移除序列内的元素

- remove：移除序列中所有与指定值相等的元素
- remove_if：移除序列中所有满足一元判断式条件的元素
- 未被移除的元素的相对顺序保持不变
- 调用者应该保证在执行此算法后不再使用原来的终点，而是使用返回的新的终点
- 注意，由于remove_if通常会在内部复制一元判断式并两次使用它，所以在执行过程中不应该改变一元判断式自身的状态
- 由于会发生元素变动，因此，这些算法不能被用于关联式容器，关联式容器提供了成员函数erase来完成类似的功能
- list提供了一个等效的成员函数，remove，由于不需要重新赋值元素，只需要重新安排指针，所以具有更好的性能
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了remove和remove_if的用法

2）复制并移除元素

- remove_copy：将指定区间中每一个元素复制到目标区间中，在复制过程中移除等于指定值的每一个元素，相当于copy和remove的组合
- remove_copy_if：将指定区间中每一个元素复制到目标区间中，在复制过程中移除满足一元判断式条件的每一个元素，相当于copy和remove_if的组合
- 注意，一元判断式在执行过程中不应该改变自身的状态
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了remove_copy和remove_copy_if的用法

2、移除重复元素

1）移除连续的重复元素

- unique：第一种形式将与前一个元素相等的元素移除，所以，源序列必须是已序的才能使用该算法来移除所有的重复元素
- unique：第二种形式将满足一个二元判断式的元素移除，注意，这里的e是指前面的那个未被移除的元素，而不是初始时和当前元素相邻的元素
- 未被移除的元素的相对顺序保持不变
- 调用者应该保证在执行此算法后不再使用原来的终点，而是使用返回的新的终点
- 注意，二元判断式在执行过程中不应该改变自身的状态
- 由于会发生元素变动，因此，这些算法不能被用于关联式容器
- list提供了一个等效的成员函数，unique，由于不需要重新赋值元素，只需要重新安排指针，所以具有更好的性能
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了unique的用法
  * 第一次调用移除了连续的重复元素
  * 第二次调用移除了满足二元判断式greater<int>的所有元素，注意，判断式不是用来将元素和初始时它前面紧邻的元素相比较，而是和它前面未被移除的“相邻”元素相比较

2）复制并移除重复元素

- unique_copy相当于copy和unique的组合
- unique_copy的两种形式都将源区间的元素复制到目标区间，并将重复的元素移除
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 复杂度：线性，执行比较操作numberOfElements次

- 示例程序展示了unique_copy的用法
  * 第一次调用移除了连续的重复元素
  * 第二次调用移除了满足differenceOne判断式的所有元素，注意，判断式不是用来将元素和它前面紧邻的元素相比较，而是和它前面未被移除的“相邻”元素相比较

八、变序性算法

- 变序性算法改变元素的顺序，但不改变元素的值
- 变序性算法不能用于关联式容器，因为关联式容器中的元素具有一定的顺序，不能随意变动

1、逆转元素顺序

- reverse会将区间中的元素全部逆序
- reverse_copy会将区间中的元素复制到目标区间中，并在复制过程中对它们进行逆序
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- list提供了一个等效的成员函数reverse，由于不需要重新对元素赋值，只需要重新安排指针，因此具有更好的性能
- 复杂度：线性，分别执行numberOfElements / 2次交换操作或者numberOfElements次赋值操作

- 示例程序展示了reverse和reverse_copy的用法

2、旋转元素顺序

1）旋转序列内的元素

- rotate旋转源区间[beg, end)中的元素，使newBeg成为新的第一个元素
- 调用者必须保证newBeg是[beg, end)中的一个有效位置，否则会导致未定义的行为
- 复杂度：线性，最多执行交换操作numberOfElements次

- 示例程序展示了rotate的用法
  * 可以使用正偏移量将元素向左起点的方向旋转，也可以使用负偏移量将元素向右终点的方向旋转
  * 只有随机存取迭代器才能像这样使用偏移量，否则，应该使用advance

2）复制并旋转元素

- rotate_copy将源区间中的元素复制到目标区间中，在复制过程中旋转元素以使newBeg成为新的第一元素，它相当于copy和rotate的组合
- 调用者必须保证newBeg是序列中的一个有效位置，否则会导致未定义的行为
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- 复杂度：线性，最多执行赋值操作numberOfElements次

- 示例程序展示了rotate_copy的用法
  * 和前面的示例程序不同，这是使用了set而不是vector，所以，需要使用advance来改变迭代器的值，因为set的迭代器是双向迭代器，而不是随机存取迭代器，不支持operator +
  * 对于set，find成员函数可以提供更好的性能，所以，这里使用了它，而不是find算法

3、排列元素

- next_permutation改变区间中的元素的顺序，使之符合下一个排列顺序
- prev_permutation改变区间中的元素的顺序，使之符合上一个排列顺序
- 如果区间中的元素能够排列成正规顺序，则这两个函数都会返回true，否则返回false
  * 对于next_permutation，正规顺序是升序，而对于prev_permutation，正规顺序是降序
  * 如果需要遍历所有的排列，就必须先将所有的元素按照升序/降序排列，然后循环调用next_permutation/prev_permutation，直到其返回false
- 复杂度：线性，最多执行交换操作numberOfElements / 2次

- 示例程序展示了利用next_permutation和prev_permutation获得所有元素的所有可能的排列顺序的过程

4、重排元素

- random_shuffle：第一种形式使用均匀分布随机数产生器来打乱区间中的元素的顺序
- random_shuffle：第二种形式使用指定操作来打乱区间中的元素的顺序，算法会为该指定操作传入一个整数值，该指定操作会返回一个大于0且小于该整数值的值
- 由于指定操作被定义为非常量引用，所以，不能传递临时值或者一般函数
- 复杂度：线性，执行交换操作numberOfElements - 1次

- 为什么random_shuffle中那个指定操作被定义为非常量引用
  * 旧式的C函数（比如，rand）将其局部状态保存在静态变量中，新式的解决方案则使用仿函数，其局部状态被封装在成员变量中，因此，随机数产生器不能具有常量性
  * 如果是值传递，每次调用都会在算法内部复制一个随机数产生器及其状态，这样就无法做到“随机”，所以，这里使用引用传递
  * 当然，如果确实需要使用同一个随机数产生器两次，那就复制它，但如果该随机数产生器的具体实现使用的是全局状态，则仍然会得到不同的随机数序列
- 如果确实需要获得同一个随机数序列两次，复制该随机数产生器就可以了，但如果该随机数产生器的具体实现涉及全局状态，那就会得到不同的随机数序列

- 示例程序展示了如何使用random_shuffle来打乱元素的顺序
  * 第一次调用使用均匀分布随机数产生器打乱序列中元素的顺序
  * 第二次调用使用自定义的MyRandom随机数产生器，它采用一个随机数计算法，效果要比直接调用rand更好

5、将元素向前移动

- partition和stable_partition都将区间中满足一元判断式的元素向前端移动
- 两种形式的差别是，不管元素是否满足一元判断式的条件，stable_partition会保持它们之间的相对顺序
- 使用该算法可以将所有的元素分为两个部分，nth_element也具有类似的能力，但它们之间是有区别的
- 注意，一元判断式在执行过程中不应该改变自身的状态
- 复杂度
  * partition：线性，最多执行指定操作numberOfElements次和交换操作numberOfElements / 2次
  * stable_partition：如果内存足够，那就是线性复杂度，执行指定操作numberOfElements次，否则，执行指定操作numberOfElements * log(numberOfElements)次

- 示例程序展示了partition和stable_partition的用法和区别

九、排序算法

- STL提供了好几种算法来对区间中的元素进行排序
  * 除了完全排序，还可以进行局部排序
  * 如果局部排序可以满足需求，应该优先使用它们，因为它们的性能通常更好
- 当然，也可以使用关联式容器来让元素自动排序
- 注意，对所有元素进行一次性排序通常比始终维持它们是已序的更高效

1、对所有元素排序

- sort和stable_sort：第一种形式使用operator <来对区间中的所有元素进行排序
- sort和stable_sort：第二种形式使用一个二元判断式作为排序规则来对区间中的所有元素进行排序
- 注意，二元判断式在执行过程中不应该改变自身的状态
- sort和stable_sort的区别是，后者可以保证相等元素的相对顺序在排序后保持不变
- 不能对list使用这些算法，因为list不支持随机存取迭代器，应该使用list的成员函数sort对其元素进行排序
- sort的平均复杂度为O(n * log(n))，为了避免可能出现的最差情况，应该使用partial_sort或stable_sort
- 复杂度
  * sort：平均执行比较操作numberOfElements * log(numberOfElements)次
  * stable_sort：如果内存足够，执行比较操作numberOfElements * log(numberOfElements)次，否则，执行比较操作numberOfElements * log(numberOfElements) * log(numberOfElements)次

- 示例程序一展示了sort的用法
- 示例程序二展示了sort和stable_sort的区别
  * lessLength用来对字符串按照字符数目进行排序
  * 只有stable_sort可以保持元素的相对位置

2、局部排序

- partial_sort：第一种形式使用operator <对begin到end的元素进行排序，但只使begin到sortEnd之间的元素是有序的
- partial_sort：第二种形式使用一个二元判断式对begin到end的元素进行排序，但只使begin到sortEnd之间的元素是有序的
- 注意，二元判断式在执行过程中不应该改变自身的状态
- partial_sort和sort的区别是，一旦begin到sortEnd之间的元素是有序的，排序操作就会停止，所以，当不需要对所有元素进行排序时，partial_sort会比sort节省时间
- 如果sortEnd和end相等，相当于对所有的元素进行排序，它的平均效率不如sort，但在最差情况下则优于sort
- 复杂度：在线性和n * log(n)之间，大约执行比较操作numberOfElements * log(numberOfElements)次

- partial_sort_copy的两种形式都将源区间复制到目标区间，同时进行排序
- partial_sort_copy相当于copy和partial_sort的组合
- 被排序的元素的数目是源区间和目标区间中元素数目的较小值
- 如果[destBeg, destEnd)中的元素数量大于或等于[sourceBeg, sourceEnd)中的元素数量，则所有的元素都会被排序并复制，这相当于copy和sort的组合
- 复杂度：在线性和n * log(n)之间，大约执行比较操作numberOfElements * log(numberOfSortedElements)次

- 示例程序展示了partial_sort_copy的用法
  * 第一次调用的目标区间只有六个元素，因此，只有六个元素被排序并复制
  * 第二次调用的目标区间有充足的空间，所以，所有的元素都被排序并复制

3、根据第n个元素排序

- nth_element的两种形式都会对区间中的所有元素进行排序，使第n个元素就位
  * 所有在第n个元素之前的元素都小于等于它，而所有在第n个元素之后的元素都大于等于它，相当于根据第n个元素将区间分为两个子集，第一个子集的元素都小于第二个子集的元素
  * 如果需要获得n个最大或者最小的元素，但并不要求它们是已序的，那么这个算法很有用
- nth_element：第一种形式使用operator <作为排序规则
- nth_element：第二种形式使用一个二元判断式作为排序规则
- 注意，二元判断式在执行过程中不应该改变自身的状态
- 和nth_element不同，partition根据某个排序规则将序列中的元素分为两个部分，所以，二者是存在区别的
- 复杂度：平均为线性

- 示例程序展示了nth_element的用法

4、堆算法

- 就排序而言，堆是一种特别的元素组织方式，应用于堆排序
- 堆可以被视为一个按照序列式集合来实现的二叉树，它具有两大性质
  * 第一个元素总是最大
  * 增加或移除一个元素需要花费对数时间

- 堆是实现priority queue的理想结构
- 为了处理堆，STL提供了四种算法
  * make_heap：将区间中的元素转换为堆
  * push_heap：为堆增加一个元素
  * pop_heap：从堆中取出下一个元素
  * sort_heap：将堆转换为已序集合，此后它就不再是堆了
- 可以为其传递一个二元判断式作为排序规则，缺省的排序规则是operator <

1）细节

- make_heap的两种形式都将区间中的元素转换为堆
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 复杂度：线性，最多执行比较操作3 * numberOfElements次

- push_heap的两种形式都将end之前的最后一个元素加入到堆中
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证最后一个元素之前的所有元素已经形成一个堆，需要新加入的元素紧随其后
- 复杂度：对数，最多执行比较操作log(numberOfElements)次

- pop_heap的两种形式都将区间中的第一个元素移到最后的位置，并使剩余的元素成为一个堆
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证进入函数时区间中的所有元素已经形成一个堆
- 复杂度：对数，最多执行比较操作2 * log(numberOfElements)次

- sort_heap的两种形式都将堆转换为一个已序序列
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证进入函数时区间中的所有元素已经形成一个堆，函数调用结束时该区间就不再是一个堆了
- 复杂度：n * log(n)，最多执行比较操作numberOfElements * log(numberOfElements)次

2）范例

- 示例程序展示了堆算法
  * 在调用make_heap后，序列中的元素被排序为堆，即，二叉树，每个节点的值都小于等于其父节点的值
  * push_heap和pop_heap虽然会替换元素，但不会改变二叉树结构的上述恒常性质

十、已序区间算法

- 执行已序区间算法的前提是，源区间必须是按照某种排序规则已序的
  * 和无序区间算法相比，它们具有明显的性能优势，通常具有对数复杂度，而不是线性复杂度
  * 如果迭代器不是随机存取迭代器，这些算法的复杂度会降为线性，但比较次数的复杂度仍然是对数复杂度
- 根据C++标准，对无序区间使用这些算法将导致未定义的行为，尽管在大部分具体实现的版本中，这些算法对无序区间仍然有效
- 对应于这些算法，关联式容器提供了对应的成员函数，当需要查找某个特定的键或值时，应该使用这些成员函数

1、查找元素

1）检查某个元素是否存在

- binary_search的两种形式都用来判断已序区间中是否包含和指定值相等的元素
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 如果想要获得被查找元素的位置，应该使用lower_bound、upper_bound或equal_range
- 调用者必须保证在应用算法时，该区间是已序的
- 复杂度：如果提供了随机存取迭代器，则为对数复杂度，最多执行比较操作log(numberOfElements) + 2次，否则为线性复杂度

- 示例程序展示了binary_search的用法

2）检查若干个值是否存在

- includes的两种形式都用来判断已序区间中是否包含另一个已序区间的所有元素，即，另一个已序区间是否是该已序区间的子集
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 如果想要获得被查找元素的位置，应该使用lower_bound、upper_bound或equal_range
- 调用者必须保证在应用算法时，两个区间都已经是按照相同的排序规则已序的
- 复杂度：线性，最多执行比较操作2 * (numberOfElements + searchElements) - 1次

- 示例程序展示了includes的用法

3）查找第一个或最后一个可能的位置

- lower_bound返回第一个大于等于指定值的元素的位置，这是可以插入指定值但不改变区间已序性的第一个位置
- upper_bound返回第一个大于指定值的元素的位置，这是可以插入指定值但不改变区间已序性的最后一个位置
- 它们的第二种形式的参数多了一个用来指定排序规则的二元判断式
- 如果想要同时获得lower_bound和upper_bound的结果，应该使用equal_range
- 调用者必须保证在应用算法时，区间已经是按照排序规则已序的
- 关联式容器提供了等效的成员函数，具有更好的性能
- 复杂度：如果提供了随机存取迭代器，则为对数复杂度，最多执行比较操作log(numberOfElements) + 1次，否则为线性复杂度

- 示例程序展示了lower_bound和upper_bound的用法

4）查找第一个和最后一个可能的位置

- equal_range的两种形式都返回与指定值相等的元素的区间，在此区间中插入指定值不会改变区间的已序性
- equal_range相当于make_pair(lower_cound(...), upper_bound(...))
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，区间已经是按照排序规则已序的
- 关联式容器提供了等效的成员函数，具有更好的性能
- 复杂度：如果提供了随机存取迭代器，则为对数复杂度，最多执行比较操作2 * log(numberOfElements) + 1次，否则为线性复杂度

- 示例程序展示了equal_range的用法

2、合并元素

1）两个已序集合的总和

- merge的两种形式都是将两个区间的元素合并后放入目标区间，使得目标区间的所有元素都按顺序排列
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，两个源区间已经是按照排序规则已序的
- 大部分实现版本可以把两个无序区间合并为一个无序区间，但出于移植性的考虑，此时应该使用copy，而不是merge
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- list提供了一个等效的成员函数merge，具有更好的性能
- 如果要确保两个源区间中都存在的元素在目标区间中只出现一次，应该使用set_union
- 如果想获得同时存在于两个源区间中的元素，应该使用set_intersection
- 复杂度：线性，最多执行比较操作numberOfElements1 + numberOfElements2 - 1次

- 示例程序展示了merge的用法

2）两个已序集合的并集

- set_union的两种形式都是将两个区间的元素合并后放入目标区间，使得目标区间的所有元素都按顺序排列
  * 目标区间的元素或者来自第一个源区间，或者来自第二个源区间
  * 对于同时出现在两个源区间中的元素，只会在目标区间中出现一次，如果源区间中存在重复的元素，则目标区间中的重复数目是两个源区间中重复数目的较大值
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，两个源区间已经是按照排序规则已序的
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- 如果想获得两个源区间中的所有元素，应该使用merge
- 复杂度：线性，最多执行比较操作2 * (numberOfElements1 + numberOfElements2) - 1次

3）两个已序集合的交集

- set_intersection的两种形式都是将两个区间的元素合并后放入目标区间，使得目标区间的所有元素都按顺序排列，目标区间的元素必须同时存在于两个源区间
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，两个源区间已经是按照排序规则已序的
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- 如果想获得两个源区间中的所有元素，应该使用merge
- 复杂度：线性，最多执行比较操作2 * (numberOfElements1 + numberOfElements2) - 1次

4）两个已序集合的差集

- set_difference的两种形式都是将两个区间的元素合并后放入目标区间，使得目标区间的所有元素都按顺序排列
  * 目标区间的元素只存在于第一个源区间，不存在于第二个源区间
  * 如果某个源区间中存在重复的元素，则目标区间中也会有重复的元素，重复的数目是第一个源区间中的重复数目减去第二个源区间中的重复数目，如果结果小于等于0，则目标区间中的重复数目也为0
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，两个源区间已经是按照排序规则已序的
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- 复杂度：线性，最多执行比较操作2 * (numberOfElements1 + numberOfElements2) - 1次

- set_symmetric_difference的两种形式都是将两个区间的元素合并后放入目标区间，使得目标区间的所有元素都按顺序排列
  * 目标区间的元素或者存在于第一个源区间，或者存在于第二个源区间，但不能同时存在于两个源区间
  * 如果某个源区间中存在重复的元素，则目标区间中也会有重复的元素，重复的数目是两个源区间中的重复数目的差值
- 第二种形式的参数多了一个用来指定排序规则的二元判断式
- 调用者必须保证在应用算法时，两个源区间已经是按照排序规则已序的
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 目标区间不能与源区间重叠
- 复杂度：线性，最多执行比较操作2 * (numberOfElements1 + numberOfElements2) - 1次

- 示例程序展示了上述各种合并算法的用法和区别

5）合并连贯的已序集合

- inplace_merge的两种形式都将两个已序源区间的所有元素合并，形成一个总区间，并且是有序的
- 复杂度：如果内存足够，则为线性，执行比较操作numberOfElements - 1次，否则为n * log(n)，执行比较操作numberOfElements * log(numberOfElements)次

- 示例程序展示了inplace_merge的用法

十一、数值算法

- 本节讲述用于处理数值的STL算法
- 这些算法也可以用于非数值元素，比如，accumulate可以用于字符串求和
- 使用这些算法需要包含头文件<numeric>

1、加工运算后产生结果

1）对序列进行某种运算

- accumulate：第一种形式在指定初始值的基础上计算所有元素的总和
- accumulate：第二种形式在指定初始值的基础上计算对每个元素执行指定操作的结果
- 复杂度：线性，执行operator +或指定操作numberOfElements次

- 示例程序展示了accumulate的用法

2）计算两个序列的内积

- inner_product：第一种形式在指定初始值的基础上计算两个区间中每个元素对的内积
- inner_product：第二种形式对两个区间中每个元素对执行一个指定操作，然后再与指定初始值执行另一个指定操作
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 注意，两个指定操作都不应该改动传入的参数
- 复杂度：线性，执行operator +或operator *各numberOfElements次，或者调用指定操作一和指定操作二各numberOfElements次

- 示例程序展示了inner_product的用法，计算两个序列的乘积之和和总和之积

2、相对值和绝对值之间的转换

1）将相对值转换为绝对值

- partial_sum：第一种形式计算源区间中的每个元素的部分和，然后将结果写入目标区间
- partial_sum：第二种形式对源区间中的每个元素以及它前面的所有元素进行指定的操作，然后将结果写入目标区间
- 第一种形式相当于把一个相对值序列转换为一个绝对值序列，所以，partial_sum正好与adjacent_difference互补
- 第一个元素只是被简单地复制
- 目标区间可以与源区间重叠
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 注意，指定的操作不应该改动传入的参数
- 复杂度：线性，执行operator +或指定操作numberOfElements次

- 示例程序展示了partial_sum的用法

2）将绝对值转换为相对值

- adjacent_difference：第一种形式计算源区间中的每个元素和它前面紧邻元素的差值，然后将结果写入目标区间
- adjacent_difference：第二种形式对源区间中的每个元素以及它前面紧邻的元素进行指定的操作，然后将结果写入目标区间
- 第一种形式相当于把一个绝对值序列转换为一个相对值序列，所以，adjacent_difference正好与partial_sum互补
- 第一个元素只是被简单地复制
- 目标区间可以与源区间重叠
- 调用者必须保证目标区间有足够的空间，否则就需要使用插入型迭代器
- 注意，指定的操作不应该改动传入的参数
- 复杂度：线性，执行operator -或指定操作numberOfElements次

- 示例程序展示了adjacent_difference的用法

3）相对值转换为绝对值的示例

- 示例程序展示了如何使用partial_sum和adjacent_difference将一个相对值序列转换为一个绝对值序列，然后再转换回来

<2023-1-17>
