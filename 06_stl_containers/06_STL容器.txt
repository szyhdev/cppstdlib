第六章 STL容器

一、容器的共通能力和操作
  1、容器的共通能力
  2、容器的共通操作
    1）初始化
    2）与大小相关的函数
    3）比较
    4）赋值和交换
二、vector
  1、vector的能力
    1）大小和容量
  2、vector的操作函数
    1）构造、拷贝和析构
    2）非变动性操作
    3）赋值
    4）元素存取
    5）迭代器相关函数
    6）插入和删除元素
  3、将vector作为一般的数组使用
  4、异常处理
  5、vector运用实例
  6、类vector<bool>
三、deque
  1、deque的能力
  2、deque的操作函数
  3、异常处理
  4、deque运用实例
四、list
  1、list的能力
  2、list的操作函数
    1）生成、复制和销毁
    2）非变动性操作
    3）赋值
    4）元素存取
    5）迭代器相关函数
    6）元素的插入和删除
    7）splice函数
  3、异常处理
  4、list运用实例
五、set和multiset
  1、set和multiset的能力
  2、set和multiset的操作函数
    1）生成、复制和销毁
    2）非变动性操作
    3）特殊的搜寻函数
    4）赋值
    5）迭代器相关函数
    6）元素的插入和删除
  3、异常处理
  4、set和multiset运用实例
  5、运行时指定排序规则
六、map和multimap
  1、map和multimap的能力
  2、map和multimap的操作函数
    1）生成、复制和销毁
    2）非变动性操作
    3）特殊的搜寻动作
    4）赋值
    5）迭代器相关函数和元素存取
    6）元素的插入和删除
  3、将map视为关联式数组
  4、异常处理
  5、map和multimap运用实例
    1）将map当作关联式数组
    2）将multimap当作字典
    3）搜寻某个具有特定值的元素
  6、综合实例
七、其他STL容器
  1、string可以被视为一种STL容器
  2、数组可以被视为一种STL容器
    1）直接运用数组
    2）一个数组包装
  3、哈希表
八、动手实现引用语义
九、各种容器的运用时机
十、细说容器内的类型和成员
  1、容器内的类型
  2、生成、复制和销毁
  3、非变动性操作
  4、赋值
  5、直接元素存取
  6、返回迭代器的各种操作
  7、元素的插入和删除
  8、list的特殊成员函数
  9、对配置器的支持
  10、综观STL容器的异常处理

- 本章详细讲解STL容器
  * 首先讲解所有容器共通的能力和操作，然后介绍每一个容器的内部数据结构、操作、性能及应用，每个容器的讲解都以一个典型的应用实例作为结束
  * 接着会讨论一个有趣的话题，各种容器的使用时机，并比较各种容器的优缺点
  * 最后介绍每一个容器的所有成员，这部分可以被视为参考手册
- C++标准程序库还提供了其他一些特殊的容器类别，包括容器适配器（stack、queue、priority queue）以及bitset和valarray，这些容器并不满足STL对容器的一般要求，所以放在其他章节介绍

一、容器的共通能力和操作

1、容器的共通能力

- 所有容器提供的都是值语义，而不是引用语义
  * 容器进行元素的插入操作时，内部进行的是拷贝操作，因此，每一个元素都必须能够被拷贝
  * 如果需要存放的不是元素的副本或者元素不具备拷贝构造函数，则只能使用指针作为元素
- 所有的元素都形成一个顺序
  * 这样就可以按照某个顺序遍历所有的元素，这一般是通过迭代器来完成的
  * 迭代器是STL算法赖以生存的关键接口
- 各项操作并不是绝对安全的，调用者必须确保传递给函数的参数符合要求
  * 违反这些要求会导致未定义的行为
  * 通常STL不会抛出异常，如果STL的使用者自定义的操作抛出了异常，会导致各不相同的行为

2、容器的共通操作

1）初始化

- 每个容器都提供一个默认构造函数、一个拷贝构造函数和一个析构函数
  * 可以以某个现有数组或者容器的区间的内容作为输入来构造容器
  * 还可以以标准输入来完成容器的初始化，注意，初始化时那对“多余”的圆括号，它可以避免该行代码被编译器误认为是一个函数声明
- 还有一些其他操作可以用来从另一个区间获取数据，不过这些操作在各个容器中并不相同，需要提供不同的参数

2）与大小相关的函数

- size返回当前容器的元素数量
- empty检查容器是否为空，相当于size() == 0
- max_size返回容器可以容纳的最大的元素数量

3）比较

- 常见的比较操作符包括==、!=、<、<=、>、>=
- 它们的定义基于以下三条规则
  * 比较操作符的两端必须是同一类型
  * 如果两个容器的所有元素按顺序相等，那么这两个容器相等
  * 判断一个容器是否小于另一个容器采用的是字典顺序
- 比较两个不同类型的容器，必须使用比较算法

4）赋值和交换

- 对容器进行赋值操作时，源容器的所有元素被拷贝到目标容器中，目标容器中的所有元素被删除，因此，容器的赋值操作的代价很高
- 如果拷贝操作后的源容器不再使用，可以使用交换操作，它的性能要好很多

二、vector

- vector是一个动态数组，它是一个将元素放入动态数组中进行管理的抽象概念
- 值得注意的是，C++标准并没有要求一定要用动态数组来实现vector
- vector中的元素必须是可赋值的、可拷贝的

1、vector的能力

- vector将元素存储在动态数组中，元素之间总是存在某种顺序，所以，vector属于有序集合
- vector支持随机存取，只要知道位置，就可以在常数复杂度时间内存取任意的元素
- vector的迭代器是随机存取迭代器，可以被用于任何STL算法

- 在vector的尾部添加或删除元素，性能都非常好
- 但如果是在首部插入或删除元素，性能就不怎么样了，因为操作点之后的元素都不得不被移动

1）大小和容量

- vector的优异性能的秘诀之一就是配置了比容纳其元素所需的更多的内存
- vector的和大小有关的函数包括size、empty、max_size

- 函数capacity返回vector实际能够容纳的元素的数量
- vector的容量之所以重要有以下两个原因
  * 一旦内存重新分配，和vector有关的所有引用、指针、迭代器都会失效
  * 重新分配内存需要耗费时间
- 函数reserve用来保留适当的容量，避免过多地重新分配内存
- 另一种方法是，在构造容器时传入额外的参数，保留足够的内存，如果类型比较复杂，调用每个元素的默认构造函数也可能很耗时，此时倒不如使用reserve

- vector的容量概念和string类似，但vector却不能像string那样通过reserve函数来缩减内存
- 既然vector的内存不会缩减，那么可以确定删除元素后相关的引用、指针、迭代器等依然有效，但插入操作就不一定了，因为它会导致vector重新分配内存空间
- 有一个窍门可以用来缩减vector的容量，交换两个vector，它们的容量也会被交换，但仍然需要注意的是，相关的引用、指针、迭代器等就都失效了

2、vector的操作函数

1）构造、拷贝和析构

- 在构造vector时可以提供元素，也可以不提供元素
- 如果只指定了要构造的vector的大小，就会用元素的默认构造函数构建新元素

2）非变动性操作

- 非变动性操作主要包括size、empty、max_size、capacity、reserve、比较操作符

3）赋值

- 可以使用赋值操作符、assign、swap来进行赋值操作
- 所有的赋值操作都可能会调用元素的默认构造函数、拷贝构造函数、赋值操作符以及析构函数

4）元素存取

- 用来存取元素的主要是operator []、at、front、back
  * 其中，只有at会进行范围检查，它在索引越界时会抛出一个out_of_range异常
  * 其他的函数都不做检查，如果发生索引越界，会导致未定义的行为
- 对于非常量vector，这些函数返回的都是元素的引用，因此，可以通过它们来更改元素的内容

5）迭代器相关函数

- 用来获得迭代器的函数包括begin、end、rbegin、rend
- vector迭代器是随机存取迭代器，理论上讲，它可以被用于STL的任何算法

- 对于vector来说，它的迭代器通常就是一个指针，指针其实就是一个随机存取迭代器，由于vector的内部实现通常就是一个数组，所以指针是适用的
- 不过，这最终还是取决于STL的具体实现

- 当发生下列情况之一时，vector迭代器不再有效
  * 在较小的索引位置插入或删除元素
  * 由于容量的变化，对内存进行了重新分配

6）插入和删除元素

- 用来插入和删除元素的函数包括insert、push_back、pop_back、erase、resize、clear
- 按照STL的管理，插入和删除元素时必须遵循以下规则
  * 迭代器必须指向一个合法的位置
  * 区间的起始位置不能位于结束位置之后
  * 不能从空容器中删除元素

- 在下列情况下，插入和删除元素的性能会更快
  * 在容器的尾部插入或删除元素
  * 容量足够大
  * 一次插入多个元素的性能比多次插入一个元素的更好

- 插入或删除元素后，位于插入或删除的位置之后的引用、指针、迭代器都会失效
- vector并未提供删除与某个值相等的元素的成员函数，这时算法就发挥作用了，比如，remove、find等

3、将vector作为一般的数组使用

- C++标准程序库并没有要求vector的元素必须分布于连续的空间中，但有份标准规格缺陷报告显示，这个缺点将得到弥补，即，以后会明确保证这一点
  * 这将意味着对于vector的任意一个合法索引，&v[i] == &v[0] + i这个表达式总是成立
  * 简单地说，任何时候需要一个动态数组，就可以使用vector，只需要获得第一个元素的地址即可，即，&v[0]
- 注意，不要将迭代器当作第一个元素的地址来传递，因为迭代器是否是一个指针取决于具体的实现

4、异常处理

- vector只支持最低限度的逻辑检查
  * at是唯一被规格说明书要求可能抛出异常的函数
  * 此外，规格说明书规定，只有一般的异常（比如，bad_alloc）或用户自定义异常才可能发生
- 如果vector的函数抛出异常，C++标准程序库做出以下保证
  * push_back发生异常，则该函数不起任何作用
  * 如果元素的拷贝操作不抛出异常，则insert函数要么成功，要么没有任何影响
  * pop_back不会抛出异常
  * 如果元素的拷贝操作不抛出异常，则erase和clear都不抛出异常
  * swap不会抛出异常
  * 如果元素的拷贝操作不抛出异常，则所有的操作函数要么成功，要么没有任何影响
- 所有这些保证都基于一个前提，析构函数不会抛出异常

5、vector运用实例

- 示例程序展示了reserve、push_back、max_size、size、capacity、swap、insert、back、copy

6、类vector<bool>

- C++标准程序库专门针对元素类型为bool的vector设计了一个特殊版本，目的是实现一个优化的vector，其空间远远小于一般定义的vector<bool>
  * 实际上，这个vector<bool>版本不能满足vector必须的所有条件，而且速度可能会慢一些，因为所有的操作都需要转换为位操作
  * 由于它可以方便地操作位，可以把它看作一个动态大小的位域，不过，如果需要的是静态大小的位域，则应该使用bitset
  * 这里的m[idx].flip()使用了代理技术，m[idx]的返回值类型其实是一个嵌套类reference，它的自动类型转换函数bool保证它可以在必要时转换为bool
- 只有非常量vector<bool>才会用到嵌套类reference，而那些存取元素的常量成员函数会直接返回普通的bool值

三、deque

- deque和vector类似，也是采用动态数组来管理元素，提供随机存取
- 不同的是，deque的首部和尾部都是开放的，可以快速添加或删除元素
- 和vector一样，deque中的元素必须是可赋值的、可拷贝的

1、deque的能力

- deque和vector的不同之处
  * 两端都可以快速地添加或删除元素
  * 存取元素时，deque的内部会多一个间接的过程，所以会稍微慢一点儿
  * 迭代器需要在不同的区块内跳转，因此，必须使用智能指针，而不是普通指针
  * 在对内存区块有所限制的系统中，deque可以包含更多的元素，因为它可以使用多个区块
  * deque不支持对容量和内存重分配时机的控制，除了首尾两端，在任何其他位置插入或删除元素，都将导致相关的引用、指针、迭代器等失效
  * deque的内存区块不再使用时会被自动释放，这意味着deque的大小是可缩减的，不过，这主要取决于具体的实现版本

- deque和vector类似的特性
  * 在中部插入或删除元素的速度相对较慢
  * 迭代器属于随机存取迭代器

- 对于下列情形，应该考虑使用deque
  * 需要在两端添加或删除元素
  * 不需要引用容器内的元素
  * 希望容器自动释放不再使用的元素，不过，标准规格书并没有保证这一点

2、deque的操作函数

- deque的操作函数包括构造函数、析构函数、非变动性操作、变动性操作
- 和vector相比，deque的操作只有以下几点不同
  * deque不提供容量操作（即，capacity和reserve）
  * deque直接提供函数来完成首部和尾部元素的插入和删除，即，push_front和pop_front
- 其他操作都相同

- 还有一些值得考虑的事情
  * 除了at，其他函数都不检查索引或迭代器的有效性
  * 插入或删除元素可能导致内存的重新分配，因此，所有的引用、指针、迭代器都会失效，唯一的例外是在首部或尾部插入元素，此时，引用和指针依然有效，但迭代器肯定是无效的了

3、异常处理

- 原则上，deque的异常处理和vector的一样，新增的push_front和pop_front类似于push_back和pop_back
- C++标准程序库做出以下保证
  * 如果push_front或push_back发生异常，则它们没有任何影响
  * pop_front和pop_back不会抛出任何异常

4、deque运用实例

- 示例程序展示了assign、push_back、push_front、copy、pop_front、pop_back、size、resize

四、list

- list使用一个双向链表来管理元素
- 和vector一样，list中的元素必须是可赋值的、可拷贝的

1、list的能力

- list的内部结构与vector和deque截然不同，所以，在能力上存在明显区别
  * list不支持随机存取，不得不顺着链表逐个遍历
  * 在任何位置上插入或删除元素都非常快
  * 插入和删除元素并不会造成其他元素的引用、指针、迭代器等失效
  * 当发生异常时，list保证“要么成功，要么没有任何影响”

- list的成员函数反映出它与vector和deque的不同
  * 由于不支持随机存取，list既不提供operator []，也不提供at
  * list没有提供容量、重新分配内存空间等函数，也没有必要
  * list提供了一些特殊的成员函数用于移动元素，这些成员函数执行起来比同名的STL全局算法更快

2、list的操作函数

1）生成、复制和销毁

- list的生成、复制和销毁和其他序列式容器相同

2）非变动性操作

- list也提供获得大小、比较等一般性操作，包括size、empty、max_size、比较操作符

3）赋值

- 和其他序列式容器一样，list也提供赋值操作，包括赋值操作符、assign、swap

4）元素存取

- list不支持随机存取，只有front和back能够直接存取元素
- 注意，在调用这些函数之前，调用者必须确保容器内至少有一个元素

5）迭代器相关函数

- list不能随机存取，所以，它的迭代器是双向迭代器，而不是随机存取迭代器
- 这意味着所有需要使用随机存取迭代器的算法都不能用于list，比如排序算法，不过，可以通过list的成员函数sort来进行排序

6）元素的插入和删除

- 在插入或删除元素方面，list提供了和deque一样的功能
- 如果需要插入或删除多个元素，单一调用比多次调用更快
- list还增加了两个成员函数，remove和remove_if，它们比全局的remove和remove_if更快，因此应该使用它们，而不是像vector和deque那样使用全局算法

7）splice函数

- list的最大好处是，在任何位置插入或删除元素都只需要常数时间
- 为了利用这个优势，list提供了一些特殊的成员函数，包括unique、splice、sort、merge、reverse等

3、异常处理

- 在所有的STL容器中，list提供了最佳的异常安全支持，几乎所有的操作都是“要么成功，要么没有任何影响”
- 仅有少数几个操作无法做出上述保证
  * 赋值操作符和sort无法保证，但它们也提供基本的保证，即，异常发生时不会泄露资源，也不会影响容器的恒常性
  * merge、remove、remove_if、unique做出上述保证的前提是，元素之间的比较操作不会抛出异常
- 用数据库的术语来说，只要不调用赋值操作符和sort，并且元素之间进行比较时不抛出异常，list就是事务安全的

4、list运用实例

- 示例程序展示了list的特殊成员函数，包括push_back、push_front、find、splice、sort、unique、merge等

五、set和multiset

- set和multiset根据特定的排序规则自动将元素排序，前者不允许重复元素，后者则允许
- set和multiset中的元素必须是可赋值的、可拷贝的、可比较的
- 默认的排序规则是less，它通过调用元素的operator <来完成比较

- 排序规则必须符合严格的弱排序规则
  * 必须是反对称的：如果x < y为真，则y < x为假
  * 必须是可传递的：如果x < y和y < z为真，则x < z也为真
  * 必须是非自反的：x < x永远为假
- 基于这些特性，排序规则也可以用于检验相等性，即，如果两个元素都不小于对方，它们就是相等的

1、set和multiset的能力

- 所有的关联式容器通常是以平衡二叉树的形式实现的
- 自动排序的优点在于通过二叉树搜寻元素时具有良好的性能，该算法具有对数复杂度，平均执行时间约是线性算法的1/50
- 不过，自动排序带来了一个重要限制，不能直接改变元素的值，因为这会打乱原来的顺序

- 改变元素的值的正确方法是，先删除旧元素，再插入新元素
- set和multiset提供的成员函数反映了这一点
  * 不提供直接存取元素的成员函数
  * 从迭代器的角度看，元素都是常量

2、set和multiset的操作函数

1）生成、复制和销毁

- set和multiset的构造函数、析构函数
- 定义排序规则的两种方式
  * 通过模板参数来定义：这种情况下，排序规则是set/multiset类型的一部分，因此，只有排序规则相同的容器才能被合并
  * 通过构造函数来定义：这种情况下，同一个类型可以使用不同的排序规则，而且，排序规则的初始值及状态可以改变，如果在运行时才能够确定排序规则或者需要在运行时改变排序规则，这种方式就可以发挥作用
- 默认的排序规则是仿函数less，它通过operator <对元素进行排序

- 注意，排序规则也被用于检验元素的相等性，即，如果两个元素都不小于对方，那么它们就是相等的
- 这样做的三个好处
  * 只需要传递一个参数作为排序规则
  * 不需要元素类型提供operator ==
  * 可以对相等性进行截然相反的定义（即，如果元素具有operator ==，这里的相等性定义可以和operator ==不同）

- 通过对容器类型进行typedef，可以简化代码的编写
- 利用构造函数的区间版本，可以从其他类型的容器、数组或者标准输入中接受元素的来源

2）非变动性操作

- set和multiset的非变动性操作包括size、empty、max_size、比较操作符
- 比较操作只能用于元素类型和排序规则都相同的set/multiset
- 比较操作采用字典序来判断一个容器是否小于另一个容器
- 如果需要比较元素类型或排序规则不同的容器，可以使用比较算法来完成

3）特殊的搜寻函数

- set和multiset在元素搜寻方面进行了优化，提供特殊的搜寻函数
- 这些函数是同名的STL算法的特殊版本，应该优先使用它们，可以获得对数复杂度，而同名的STL算法具有线性复杂
- set和multiset的搜寻函数包括count、find、lower_bound、upper_bound、equal_range
- 如果lower_bound等于upper_bound或者equal_range的区间的首和尾相等，则容器中不存在与指定值相等的元素

4）赋值

- set和multiset只提供所有容器都提供的基本的赋值操作
- 赋值操作两边的容器必须具有相同的元素类型，如果排序规则不同，则排序规则也会被赋值或替换
- set和multiset的赋值操作包括赋值操作符、swap

5）迭代器相关函数

- set和multiset不支持直接存取元素，对元素的存取是通过迭代器进行的
- 和其他关联式容器一样，set和multiset的迭代器是双向迭代器，因此，对于只能用于随机存取迭代器的算法，set和multiset就无法使用了
- 更重要的是，set和multiset的所有元素的键都被视为常量，因此，不能针对set和multiset使用变动性算法，此时只能使用set和multiset提供的成员函数

6）元素的插入和删除

- 插入和删除多个元素，一次调用比多次调用快很多
- set和multiset的插入和删除元素的函数包括insert、erase、clear

- 对于insert函数的单参数版本，set和multiset的返回类型不同，原因是multiset允许重复元素，而set不允许
  * set会返回pair类型，其中，second用来指明插入操作是否成功，first用来指明新元素的位置
  * multiset则直接返回一个迭代器
- 对于insert函数的带有位置参数的版本，不论是set还是multiset，它们都返回一个迭代器，这确保了各种容器都具有一个通用的接口，一般性插入型迭代器正是依靠这个接口来实现的

- 要删除某个特定值的元素，直接调用erase即可
- 和list不同的是，erase并没有取名为remove，因为它们的行为不同，erase返回被删除的元素的数量，对于set而言，要么是0，要么是1
- 由于multiset允许重复元素，所以，不能通过erase来删除重复元素中的第一个，此时可以通过配合使用成员函数find来完成，注意，这里的find是成员函数，而不是全局算法
- 还有一个返回值不一致的地方，序列式容器和关联式容器的erase成员函数的返回值并不相同
  * 前者返回一个迭代器，而后者没有返回值
  * 存在这种差别完全是因为性能，对于关联式容器，返回下一个元素的位置是一件耗时的任务
  * 如果要编写适用于所有容器的代码，就必须忽略返回值

3、异常处理

- set和multiset是基于节点的容器
  * 如果节点构建失败，容器会保持原样
  * 另外，由于析构函数通常不抛出异常，删除元素不可能失败
- 不过，在插入多个元素时，由于元素的顺序不一定能够得到保证，所以，无法做到“要么成功，要么没有任何影响”
- 而对于删除多个元素，则总是能够成功
- 如果排序规则的复制或赋值操作抛出异常，swap也可能抛出异常

4、set和multiset运用实例

- 示例程序展示了insert及其返回值、基于另一个容器的区间构建一个set、erase及其返回值、find
- 如果两个容器有不同的排序规则，即，它们的类型不同，就不能进行赋值或比较操作，但由于元素的类型相同，所以，可以通过一些有能力处理不同类型的容器的算法来进行操作，比如，基于区间的构造函数

5、运行时指定排序规则

- 前面展示的都是把排序规则作为模板参数传入或者采用默认的排序规则，这都是把排序规则作为容器的类型定义的一部分进行处理的
- 但有时候需要在运行时指定排序规则或者针对同一个容器类型使用不同的排序规则，这时就需要在运行时传入一个排序规则

- 示例程序展示了被用作仿函数的模板类RuntimeCmp，它的构造函数可以接受一个枚举类型来指定是按照升序还是降序进行排序
  * 局部函数fill可以处理元素类型相同的两个容器，尽管它们的排序规则并不相同
  * 在将一个容器赋值给另一个容器后，不仅赋值了元素，同时也赋值了排序规则

六、map和multimap

- map和multimap将键-值对作为元素进行管理
  * 它们可以根据键的排序规则对元素排序
  * multimap允许重复元素，而map不允许
- map和multimap的元素的键和值的类型必须满足两个条件
  * 键和值的类型都必须是可赋值的、可拷贝的
  * 同时，键的类型必须是可比较的
- 和set/multiset一样，排序规则必须符合严格的弱排序规则

1、map和multimap的能力

- 和所有的标准关联式容器一样，map/multimap通过平衡二叉树来实现
  * 典型情况下，map/multimap使用和set/multiset一样的数据结构，因为，set/multiset其实可以被看作map/multimap的特例，即，键和值指向同一个对象
  * 因此，map/multimap具有set/multiset的所有功能
- map/multimap和set/multiset的不同之处在于，它们的元素是键-值对，并且可以被用作关联式数组

- map/multimap会对元素自动排序，这使得map/multimap有一条重要的限制，不能改变元素的键，因为这样做会破坏排序规则
- 正确的做法是，先把旧元素删除，然后再插入新元素

2、map和multimap的操作函数

1）生成、复制和销毁

- map和multimap的构造函数和析构函数
- 定义排序规则的两种方式
  * 通过模板参数来定义：这种情况下，排序规则是map和multimap类型的一部分，因此，只有排序规则相同的容器才能被合并
  * 通过构造函数来定义：这种情况下，同一个类型可以使用不同的排序规则，而且，排序规则的初始值及状态可以改变，如果在运行时才能够确定排序规则或者需要在运行时改变排序规则，这种方式就可以发挥作用
- 默认的排序规则是仿函数less，它通过operator <对元素进行排序

2）非变动性操作

- map和multimap的非变动性操作包括size、empty、max_size、比较操作符
- 比较操作只能用于元素类型和排序规则都相同的map和multimap
- 比较操作采用字典序来判断一个容器是否小于另一个容器
- 如果需要比较元素类型或排序规则不同的容器，可以使用比较算法来完成

3）特殊的搜寻动作

- 和set和multiset一样，map和multimap也在元素搜寻方面进行了优化，提供特殊的搜寻函数
- find用来搜寻具有某个键的第一个元素，但它不能被用来搜寻具有某个特定值的元素，此时应该使用find_if，或者自己编写一个循环来实现搜寻操作
- 对于lower_bound、upper_bound、equal_range，其行为和set/multiset的相应函数类似，唯一不同的就是元素是一个键-值对

4）赋值

- map和multimap只提供所有容器都提供的基本的赋值操作
- map和multimap的赋值操作包括赋值操作符、swap
- 赋值操作两边的容器必须具有相同的元素类型，如果排序规则不同，则排序规则也会被赋值或替换

5）迭代器相关函数和元素存取

- map和multimap不支持直接存取元素，对元素的存取是通过迭代器进行的，不过，map支持operator []，可以直接存取元素
- 和其他关联式容器一样，map和multimap的迭代器是双向迭代器，因此，对于只能用于随机存取迭代器的算法，map和multimap就无法使用了
- 更重要的是，map和multimap的所有元素的键都被视为常量，因此，不能针对map和multimap使用变动性算法，此时只能使用map和multimap提供的成员函数
- 如果一定要改变元素的键，应该用一个值相同的元素取代旧元素，对于map，使用operator []可以方便地修改元素的键

6）元素的插入和删除

- map和multimap的插入和删除元素的函数包括insert、erase、clear
- 插入元素时，元素的键被视为常量，所以需要传递正确的类型，或者提供隐式或显式转换
- 插入元素的方法
  * 使用value_type，这是容器本身提供的类型
  * 使用pair，注意元素的键被视为常量
  * 使用make_pair，注意元素的键被视为常量

- erase用来删除具有某个指定键的元素，它返回被删除的元素数量，对于map而言，要么是0，要么是1
- 由于multimap允许重复元素，所以，不能通过erase来删除重复元素中的第一个，此时可以通过配合使用成员函数find来完成
  * 注意，这里的find是成员函数，而不是全局算法，前者的速度更快
  * 而且，find不能用于查找具有某个指定值（而不是键）的元素

- 使用erase删除迭代器所指向的对象时，迭代器不再有效，继续对它进行操作将导致未定义的行为
  * 如果erase总是返回下一个元素的迭代器位置，代码就好些了，但STL的设计者否决了这个想法，因为如果用户不需要该功能，这会白白地浪费时间
  * 正确的做法是，coll.erase(pos++)，pos++会先将pos移向下一个元素，然后返回一个原来的位置传给erase

3、将map视为关联式数组

- 关联式容器不提供对元素的直接存取，必须依靠迭代器来完成，但map是个例外，它通过重载operator []实现了下标操作符，从而可以通过键来访问元素
- operator []的索引不一定是整数，而且，即使容器中不存在对应的键，也不会出错，容器内会被自动插入一个新元素

- 关联式数组的行为毁誉参半，优点是可以通过方便的接口插入新元素，缺点是可能不小心误插入新元素
- 另外，这种插入方式比一般的插入方式慢，原因是新元素会先通过默认的构造函数构造出来，然后马上又被真正的值覆盖了

4、异常处理

- map和multimap的异常处理和set/multiset的一样

5、map和multimap运用实例

1）将map当作关联式数组

- 以股票名称作为键，以股票价格作为值，把map当作一个关联数组来显示股票行情

2）将multimap当作字典

- 把multimap用作一个字典

3）搜寻某个具有特定值的元素

- 使用find_if来搜寻具有某个特定值的元素

6、综合实例

- 示例程序通过map和string在运行时指定排序规则，展示了以下技巧
  * 如何使用map
  * 如何编写用来定义排序规则的仿函数
  * 如何在运行时指定排序规则
  * 如何进行大小写不敏感的字符串比较
- 当使用大小写不敏感的排序规则时，结果出现了混乱，再次证明为了表现字典，应该采用multimap而不是map

七、其他STL容器

- STL是一个框架，除了提供标准容器，它也允许使用字符串或者数组作为容器，或者自己定义特殊的容器以满足特殊的需要
- 以下是自定义能够融入STL的容器的三种方法
  * 侵入性做法：直接提供STL容器需要的接口
  * 非侵入性做法：通过提供特殊的迭代器来衔接特殊的容器和算法，这需要的只是遍历容器的能力
  * 包装法：将上述两种方法相结合，实现一个包装类来包装任意的数据结构，对外提供与STL容器类似的接口

- 任何STL容器都应该能够通过不同的配置器进行参数化
- C++标准程序库提供了一些特殊函数和类型，帮助编写配置器并处理未初始化的内存

1、string可以被视为一种STL容器

- string是以侵入式做法实现STL容器的一个好例子
- string可以被视为以字符作为元素的容器
- string提供了STL容器的接口，比如begin和end，它们返回随机存取迭代器，可以用来遍历整个string
- string还提供了一些特殊操作，比如push_back，用来支持迭代器和迭代器适配器，比如back插入器
- string通常被作为一个对象处理，当需要处理其中的每个字符时，可以使用STL算法，而string本身不具备这些能力

2、数组可以被视为一种STL容器

- 数组也可以被当作容器使用，但由于它不是类，所以无法提供begin或end之类的成员函数，所以，可以使用非侵入式做法或者包装法

1）直接运用数组

- 非侵入式做法很简单，只要能够提供遍历数组的元素的迭代器即可
- 事实上，这样的迭代器已经存在了，这就是普通指针
- STL在设计迭代器的时候，就决定让它具有和普通指针一样的接口，所以，指针本身就可以被用作迭代器

2）一个数组包装

- 包装法是在数组外面包装一层常用的容器接口
- 该包装类提供begin、end、operator []之类的成员函数，这样就可以对它使用某些STL算法

3、哈希表

- 有一种数据结构可以被用于实现集合，但却没有被包含在C++标准程序库中，这就是哈希表
- 在C++社区中已经存在哈希表的实际版本，一般会提供四种哈希表，包括hash_set、hash_multiset、hash_map、hash_multimap
- 关于哈希表的具体实现，可以参见STLport
- 由于哈希表尚未标准化，所以，不同的实现版本在细节上可能会有所不同

八、动手实现引用语义

- 要在STL容器中使用引用语义，不管是因为复制元素的代价太大还是需要在不同的容器中共享元素，都需要采用智能指针，以避免可能的错误
- 一个可行的解决方法是，对指针指向的对象进行引用计数
  * 这里的CountedPtr有点类似于auto_ptr，区别在于对这个指针进行复制后，原指针和新的指针都是有效的
  * 只有当指向同一个对象的最后一个CountedPtr被销毁后，该对象才会被销毁
- 关于其他的智能指针类型，可以参考Boost程序库，它是对C++标准程序库的扩充，在那里和CountedPtr对应的类型是shared_ptr

九、各种容器的运用时机

- 如何选择最佳的容器类型并不像想象中的那样简单，比如，如果容器的元素数量很少，就可以忽略其复杂度，因为线性复杂度搭配快速的元素处理比对数复杂度搭配缓慢的元素处理更划算

- 缺省情况下应该使用vector，它的内部结构简单，允许随机存取，数据处理也够快
- 如果经常需要在容器的首部和尾部添加或删除元素，应该使用deque
  * 如果希望删除元素时能够自动缩减内存，也应该使用deque
  * 和vector相比，deque使用多个区块，因此，可以容纳更多的元素
- 如果经常需要在容器的中部插入、删除或移动元素，应该考虑使用list
  * list可以在常数时间内将元素从一个容器移动到另一个容器
  * 但由于不支持随机存取，访问中部元素的性能会大打折扣
  * 和所有基于节点的容器类似，只要元素还是容器的一部分，指向它们的迭代器就不会失效，而vector和deque则完全不同
- 如果需要达到“要么成功，要么没有任何影响”的效果，应该使用list，或者使用关联式容器
  * 对于list，赋值操作符和sort无法保证该效果，而且，如果比较操作符可能抛出异常，则merge、remove、remove_if、unique也无法保证该效果
  * 对于关联式容器，多元素插入操作无法保证该效果，而且，如果比较操作符可能抛出异常，则swap也无法保证该效果
- 如果经常需要按照某个排序规则来搜寻元素，就应该使用以该排序规则进行排序的set或multiset
  * 对数复杂度的性能比线性复杂度的快10倍，这是二叉树的功劳
  * 而哈希表通常比二叉树又快5~10倍，所以，哈希表是更好的选择，即使它没有被标准化
  * 但是，如果元素需要排序，哈希表就不适合了
- 如果需要处理键-值对，应该使用map或multimap
  * 如果需要使用关联式数组，应该使用map
  * 如果需要使用字典式结构，应该使用multimap

- 如何根据两种不同的排序规则对元素进行排序
  * 比如，插入元素时使用客户提供的排序规则，搜寻元素时使用另一种排序规则来快速存取元素
  * 此时一般需要两个set或map，各自拥有不同的排序规则，但共享相同的元素
- 关联式容器具有自动排序的功能，但这并不意味着它在排序方面的效率很高
  * 事实上，由于每插入一个元素都要进行一次排序，所以，速度还不如序列式容器
  * 通常的做法是，先插入所有的元素，然后进行一次完全的排序

十、细说容器内的类型和成员

- 本节讨论各种STL容器，介绍STL容器支持的所有操作函数，类型和成员按照功能进行分组

1、容器内的类型

- 容器内的类型包括value_type、reference、const_reference、iterator、const_iterator、reverse_iterator、const_reverse_iterator、size_type、difference_type、key_type、mapped_type、key_compare、value_compare、allocator_type

2、生成、复制和销毁

- 容器的生成、复制和销毁函数包括默认构造函数、以排序规则为参数的构造函数、拷贝构造函数、以元素数量为参数的构造函数、以元素数量和某个元素为参数的构造函数、以容器的区间为参数的构造函数、以容器的区间和排序规则为参数的构造函数、析构函数

3、非变动性操作

- 大小相关操作包括size、empty、max_size
- 容量操作包括capacity、reserve
- 元素之间的比较操作包括各种比较操作符
- 关联式容器特有的非变动性操作包括count、find、lower_bound、upper_bound、equal_range、key_comp、value_comp

4、赋值

- 赋值操作包括赋值操作符、以元素数量和某个元素为参数的assign、以容器的区间为参数的assign、成员函数swap、全局算法swap

5、直接元素存取

- 直接存取元素的操作包括at、operator []、front、back

6、返回迭代器的各种操作

- 返回迭代器的各种操作包括begin、end、rbegin、rend

7、元素的插入和删除

- 元素的插入操作包括以元素为参数的insert、以位置和元素为参数的insert、以位置、元素数量和某个元素为参数的insert、以容器的区间为参数的insert、以位置和容器的区间为参数的insert、push_front、push_back
- 元素的删除操作包括remove、remove_if、以元素为参数的erase、以位置为参数的erase、以容器的区间为参数的erase、pop_front、pop_back、resize、clear

8、list的特殊成员函数

- list的特殊成员函数包括unique、以位置和list为参数的splice、以位置、list和list中的位置为参数的splice、以位置、list和list中的区间为参数的splice、sort、以排序规则为参数的sort、以list作为参数的merge、以list和排序规则为参数的merge、reverse

9、对配置器的支持

- 所有的STL容器都可以与某个配置器所定义的内存模型配合工作
- 标准STL容器要求，配置器的每一个实体都是可互换的，因此，一个容器的内存空间可以通过另一个同类型容器进行释放，这样，将元素在两个容器之间移动时并不会出现问题

- 基本的配置器相关成员函数包括allocator_type、get_allocator
- 带有配置器参数的构造函数包括以配置器为参数的构造函数、以排序规则和配置器为参数的构造函数、以元素数量、某个元素和配置器为参数的构造函数、以容器的区间和配置器为参数的构造函数、以容器的区间、排序规则和配置器为参数的构造函数

10、综观STL容器的异常处理

- 不同的容器在异常发生时给出不同程度的保证
- 在异常发生时，通常并不会泄露资源或破坏容器的恒常性
- 有些操作则提供更强的保证，要么成功，要么没有任何影响，相当于commit-or-rollback
- 对于vector、deque、list而言，resize要么相当于insert，要么相当于erase，要么没有任何影响，所以，它提供的保证是insert和erase提供的保证的组合

<2022-12-5>
