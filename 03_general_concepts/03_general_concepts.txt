第三章 一般概念

一、名字空间std
二、头文件
三、错误处理和异常处理
  1、标准异常类型
    1）语言本身所支持的异常
    2）标准程序库支持的异常
    3）程序作用域之外的异常
    4）标准程序库抛出的异常
    5）异常类型的头文件
  2、异常类型的成员
  3、抛出标准异常
  4、从标准异常类型派生新类型
四、配置器

- 本章介绍C++标准程序库中的基本概念
- 几乎所有的C++标准程序库组件都用到这些概念，包括名字空间std、头文件、错误处理和异常处理、配置器等

一、名字空间std

- 所谓名字空间是指标识符的某种可见范围
- 名字空间具有扩展开放性，可以出现在任何源代码文件中，因此，可以在一个名字空间定义一些组件，并把它们散布在多个物理模块中
- 典型的例子就是C++标准程序库，它的所有标识符都被定义在名字空间std中

- 使用C++标准程序库的任何标识符的三种方式
  * 使用名字空间直接指定标识符，比如，std::cout
  * 使用using namespace::xxx，然后就可以直接使用xxx了，比如，using std::cout
  * 使用using namespace xxx，这样可以打开名字空间xxx，暴露其中的所有标识符，比如，using namespace std
- 注意，第三种方式可能导致意外的名字冲突，甚至导致不一样的行为，如果不是很确定，最好避免使用它

二、头文件

- 将C++标准程序库的所有标识符定义在名字空间std中是在标准化过程中引入的，这不具有向下兼容性，因为原来标识符都是定义在全局范围的
- 此外，标准化过程中有些类的接口也发生了变动
- 为此，引入了一套新的头文件命名风格，同时，现有的代码可以使用旧的头文件以达到向下兼容的目的

- 借此机会，正好可以把头文件的扩展名加以规范
  * 之前，头文件的扩展名五花八门，包括.h、.hpp、.hxx等
  * 规范后的头文件扩展名非常简洁，即，没有扩展名，比如，<string>
  * 这种写法也适合于C标准头文件，但必须带上前缀c，而且也不再有扩展名，比如，<cstring>
- 在这些头文件中，所有的标识符都定义在名字空间std中

- 不过，从操作系统的角度看，新的头文件命名方式并不意味着这些头文件没有扩展名，如何对头文件进行处理，是由编译器决定的，它可以为头文件自动添加一个扩展名
- 对于自己编写的头文件，加上一个扩展名仍然是一个好主意

- 为了向下兼容C，旧的头文件仍然有效。还可以继续使用它们，比如，<stdlib.h>
- 像<iostream.h>这样的旧的头文件，标准并未加以规范，这意味着这些头文件不再被标准支持
- 注意，除了引入了名字空间std之外，头文件还包含其他许多改变，因此，要么使用旧的头文件，要么完全使用新的命名方式

三、错误处理和异常处理

- C++标准程序库由不同的部分组成，设计和实现风格迥异，比如，错误处理和异常处理
  * string支持错误处理，检查所有可能发生的错误
  * STL和Valarrays注重效率，因此，几乎不检查任何逻辑错误，只在发生错误时抛出异常

1、标准异常类型

- 语言本身和标准程序库抛出的所有异常，都派生自基类exception，它们共同构成一个类体系
- 这些标准异常类型可以分为三组，语言本身支持的异常、标准程序库支持的异常和程序作用域之外的异常

1）语言本身所支持的异常

- 这类异常用来支持语言的某些特性，不属于标准程序库的一部分，而是核心语言的一部分
  * new操作符失败，会抛出bad_alloc异常
  * dynamic_cast失败，会抛出bad_cast异常
  * typeid失败，会抛出bad_typeid异常
  * 发生异常规格之外的非预期的异常，会抛出bad_exception异常

2）标准程序库支持的异常

- 标准程序库的异常总是派生自logic_error
  * 从理论上讲，总是可以通过某些手段来避免程序中的逻辑错误，比如，对函数的参数进行检验
  * 所谓逻辑错误包括违反逻辑前提或违反类的不变性
- 标准程序库提供以下逻辑错误类型
  * invalid_argument表示无效的参数
  * length_error指出某个行为可能超出了最大极限
  * out_of_range指出参数值不在预期范围内
  * domain_error指出专业领域内的错误
- 此外，标准程序库的I/O提供了一个io_base::failure的特殊异常，会在数据流由于错误或者到达文件尾部而发生状态改变时抛出

3）程序作用域之外的异常

- 派生自runtime_error的异常用来指出不在程序范围内且不容易避免的异常
  * range_error指出内部计算时发生区间错误
  * overflow_error指出算术计算发生向上溢位
  * underflow_error指出算术计算发生向下溢位

4）标准程序库抛出的异常

- 标准程序库本身可能抛出rang_error、out_of_range和invalid_argument异常
- 由于标准程序库会用到语言特性和程序员编写的代码，因此可能间接地抛出任何异常
- 标准程序库的具体实现还可能提供额外的非标准异常类型，这可能会带来代码移植方面的问题

5）异常类型的头文件

- exception和bad_exception定义在头文件<exception>中
- bad_alloc定义在头文件<new>中
- bad_cast和bad_typeid定义在头文件<typeinfo>中
- ios_base::failure定义在头文件<ios>中
- 其他异常类型定义在头文件<stdexcept>中

2、异常类型的成员

- 为了在catch语句中处理异常，必须提供必要的接口
- 所有标准异常的接口都包含一个成员函数，what，用来获取类型本身之外的附加信息
- 标准异常的其他成员用来处理创建、复制、赋值、销毁等操作
- 根据抛出的异常的类型，程序员可以做出进一步的评估

3、抛出标准异常

- 程序员可以在自己的程序中抛出某些标准异常
  * 构建这样的标准异常时，一般需要提供一个字符串参数，它将成为被what返回的字符串
  * 提供这个功能的标准异常包括logic_error及其派生类、runtime_error及其派生类、ios_base::failure及其派生类
- 程序员不能抛出exception，也不能抛出任何用来支持语言核心特性的异常

4、从标准异常类型派生新类型

- 另一个在程序中使用标准异常类型的情况是，从exception直接或间接地派生出一个新类型
- 由于what是个虚函数，程序员可以自己实现what，以确保一切运行正常

四、配置器

- C++标准程序库中有很多地方采用特殊的对象来处理内存和寻址，这种对象称为“配置器”
- 配置器是一种特定的内存模型，它是一种抽象，表现出从内存需求到内存底层调用的转换
- 通过使用多个不同的配置器对象，可以在同一个程序中采用不同的内存模型

- 配置器最初是作为STL的一部分引入的，用来处理PC上不同类型的指针的相关问题，比如，near、far等
- 现在，配置器已经成为一种技术方案的基础，使得共享内存、垃圾回收、面向对象数据库等特定的内存模型能够保持统一的接口
- C++标准程序库定义了一个缺省的配置器，allocator
  * 缺省配置器可以用在任何需要配置器作为参数的地方，它执行内存分配的一般方法，即，调用new和delete，不过，C++标准并没有规定具体如何实现它
  * 绝大多数程序只需要使用缺省的配置器即可，尽管有时候需要提供自定义的配置器以满足特定的需求

<2022-12-24>
