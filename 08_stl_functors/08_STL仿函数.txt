第八章 STL仿函数

一、仿函数的概念
  1、仿函数可以作为排序规则
  2、拥有内部状态的仿函数
  3、for_each的返回值
  4、判断式和仿函数
二、预定义的仿函数
  1、函数适配器
  2、针对成员函数的函数适配器
  3、针对一般函数的函数适配器
  4、让自定义仿函数也可以使用函数适配器
三、辅助仿函数
  1、一元组合函数适配器
    1）以compose_f_gx进行嵌套计算
    2）以compose_f_gx_hx组合两个运作规则
  2、二元组合函数适配器

- 本章介绍函数对象，也称为“仿函数”
- 本章涵盖STL预定义的所有仿函数、函数适配器以及功能复合的概念

一、仿函数的概念

- 所谓仿函数，就是一个定义了operator ()的对象
  * 表达式fo()其实是调用了仿函数fo的operator ()
  * 仿函数可以被视为一种函数，但它采用了更复杂的编写方式，并非所有的语句都放在函数体中
- 这种定义方式看着有点复杂，却有三大好处
  * 仿函数比一般的函数更灵活，因为它可以拥有状态
  * 每个仿函数都是一个类型，因此可以作为模板参数来传递
  * 在执行速度上，仿函数通常比函数指针更快

1、仿函数可以作为排序规则

- 程序员经常需要将类对象放入容器中，这时无法使用一般的operator <来为这些对象排序，此时仿函数就可以派上用场
- 示例程序中的PersonSortCriterion是一个类型，所以可以作为模板参数传递给set，set也因此拥有了自己独特的类型，一般的函数则无法做到这一点
  * 以PersonSortCriterion作为排序规则的set具有自己独特的类型，不能与具有不同排序规则的其他set进行合并或赋值
  * 所以，尽管无法回避set的自动排序特性，却可以为其设计出类型一致但排序规则不同的仿函数

2、拥有内部状态的仿函数

- 示例程序一展示了拥有状态的仿函数
  * 每次仿函数被调用，都返回一个整数值，并对其递增
  * 对于初始的整数值，则可以通过构造函数来指定
- 这里的仿函数是以值传递的方式传给算法的，因此，算法不会改变仿函数的状态，这样做的好处是，可以为算法传递常量仿函数或者临时仿函数

- 如果需要通过仿函数从算法中获得“结果”，要么传递仿函数的引用，要么利用for_each算法的返回值
- 示例程序二展示了以引用方式传递仿函数的用法
  * 第一次调用generate_n时，仿函数seq以引用方式传递，这只需要在模板参数中指明IntSequence&即可
  * 第二次调用generate_n使用了临时仿函数IntSequence(42)
  * 第三次调用generate_n时，仿函数seq的状态已经被更新，因此，新产生的整数序列从5开始
  * 第四次调用generate_n时，仿函数seq的状态没有改变，因为第三次调用采用的是值传递的方式

3、for_each的返回值

- for_each有一个独门绝技，它可以返回传给它的仿函数，这样就可以获得仿函数的新状态了
- 在示例程序中，使用for_each来处理一个序列的平均值
  * for_each针对序列中的每一个元素调用传入的仿函数，并将返回的仿函数赋值给mv，通过mv.value()就可以查询仿函数的状态以获得结果
  * 如果为该仿函数添加一个类型转换函数operator double，就可以直接输出mv的平均值了

4、判断式和仿函数

- 所谓判断式，就是返回布尔值的函数或仿函数
- 不过，对于STL而言，并非所有返回布尔值的函数都是合法的判断式
- 示例程序展示了remove_if算法使用仿函数Nth的意外行为
  * 由于算法在内部保存了一份Nth的副本，第3个和第6个元素都被删除了
  * 为了获得正常行为，不要传递“行为取决于被拷贝或被调用的次数”的仿函数
  * 要做到这一点，只需要将仿函数的operator ()声明为const，确保其不会修改仿函数的状态

二、预定义的仿函数

- 预定义的仿函数包括negate、plus、minus、multiplies、divides、modulus、equal_to、not_equal_to、less、greater、less_equal、greater_equal、logical_not、logical_and、logical_or
  * 在对对象进行排序或者比较时，一般会以less仿函数作为默认规则
  * 因此，预设的排序操作通常按升序进行排列
- 要使用预定义的仿函数，必须包含头文件<functional>

1、函数适配器

- 所谓函数适配器是指能够将仿函数与另一个仿函数、某个值或者某个函数组合起来的仿函数
- 函数适配器在头文件<functional>中声明

- 预定义的函数适配器包括bind1st、bind2nd、not1、not2
- bind2nd可以将一个二元仿函数转换为一元仿函数，它会将传给它的第二个参数作为由第一个参数指定的二元仿函数的第二个参数
- 函数适配器本身也是仿函数，可以结合其他仿函数形成更强大的表达式，这种方式称为“功能复合”

2、针对成员函数的函数适配器

- C++标准程序库提供了一些额外的函数适配器，用来调用容器内元素的成员函数
  * mem_fun_ref：调用某个对象的常量成员函数
  * mem_fun：调用某个对象指针的常量成员函数

- 示例程序展示了使用mem_fun_ref调用vector中的每个元素的print成员函数的方法
  * 不能直接将&Person::print传给for_each，因为for_each会针对该成员函数指针调用operator ()，这将导致编译错误
  * mem_fun_ref将对自己的operator ()的调用转换为对元素的成员函数的调用
  * 通过bind2nd的配合，还可以向被调用的成员函数传递一个参数

- mem_fun_ref之所以这样命名是因为在它之前mem_fun已经存在了，mem_fun的作用对象是指向对象的指针，因此，如果命名为mem_fun_ptr，也许更不容易混淆
  * mem_fun_ref和mem_fun都可以调用无参数或者单一参数的成员函数，但无法调用更多参数的成员函数，因为这需要大量的辅助的仿函数
  * 注意，mem_fun_ref和mem_fun调用的成员函数必须是const，C++标准程序库没有提供针对非const成员函数的函数适配器

3、针对一般函数的函数适配器

- 针对一般函数的函数适配器是ptr_fun
  * not1(ptr_fun(check))用来过滤某个检验动作失败的元素
  * bind2nd(ptr_fun(strcmp, ""))用来过滤空的字符串

4、让自定义仿函数也可以使用函数适配器

- 要使自定义仿函数也能和函数适配器搭配使用，必须满足一些条件，即，必须提供其参数和返回值的类型
- C++标准程序库提供了一些结构来简化这个操作，unary_function和binary_function，从它们派生出的仿函数可以轻松地满足和函数适配器搭配使用的条件
- 函数适配器的概念也是抽象的，任何东西，只要其行为像函数适配器，它就是一个函数适配器

- 示例程序展示了自定义仿函数fopow和bind1st、bind2nd一起使用的情况
  * 这里的fopow针对float和int两种类型来实例化
  * 如果基数和指数均为int，本来应该使用两个int来调用pow，但pow虽然具有多种重载形式，并没有覆盖到所有的基本类型，所以并不具有良好的移植性

三、辅助仿函数

- 仿函数的组合能力很重要，可以通过简单的仿函数构造出非常复杂的仿函数
- 一般而言，所有的函数行为都可以通过仿函数的组合来实现，但C++标准程序库并没有提供足够的函数适配器来达到这个目标，比如，无法将两个一元运算A和B组合为A and B的公式

- 下列组合型函数适配器很有用，但是它们并没有被纳入标准规范中
  * f(g(elem))：一个一元组合函数，本书中采用的名称是compose_f_gx
  * f(g(elem1, elem2))：一个二元组合函数，本书中采用的名称是compose_f_gxy
  * f(g(elem), h(elem))：两个一元组合函数，它们使用相同的参数，本书中采用的名称是compose_f_gx_hx
  * f(g(elem1), h(elem2))：两个一元组合函数，它们使用不同的参数，本书中采用的名称是compose_f_gx_hy

1、一元组合函数适配器

1）以compose_f_gx进行嵌套计算

- 最简单、最基本的组合型函数适配器是将某个一元函数的结果传给另一个一元函数
- 其实，这相当于嵌套调用两个一元函数

2）以compose_f_gx_hx组合两个运作规则

- 这也许是最重要的组合型函数适配器，它允许将两个规则进行逻辑组合，形成单一规则
- 其实，这相当于按照一定的逻辑规则组合了两个一元判断式

2、二元组合函数适配器

- 二元组合函数适配器可以对两个接受不同参数的一元函数的结果进行处理，即，compose_f_gx_hy
- 示例程序展示了在一个字符串中按照大小写无关的规则查找另一个字符串

<2022-12-22>
