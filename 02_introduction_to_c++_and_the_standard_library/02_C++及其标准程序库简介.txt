第二章 C++及其标准程序库简介

一、沿革
二、新的语言特性
  1、模板
    1）非类型模板参数
    2）关键字typename
    3）成员模板
  2、基本类型的显式初始化
  3、异常处理
  4、名字空间
  5、bool类型
  6、关键字explicit
  7、新的类型转换操作符
  8、常量静态成员的初始化
  9、main函数的定义式
三、复杂度和Big-O表示法

一、沿革

- C++的标准化过程始于1989年，到1997年底完成，不过，最终的标准规格到1998年9月才发布
- 整个努力的结果是，ISO发布了一份长达750页的标准规格，“Information Technology—Programming Language—C++”，文件编号为ISO/IEC 14882-1998

- 标准规格的建立是C++的一个重要里程碑，它准确定义了C++的内容和行为，简化了C++的教学和使用及其在不同平台之间的移植工作，给予用户选择不同编译器的自由
- 标准程序库作为C++标准规格的一部分，提供一系列核心组件，用来支持I/O、字符串、容器、算法、数值计算、国际化等

- 这份标准规格并非从零开始，而是基于Bjarne Stroustrup对这个语言的描述
- 但标准程序库却不是基于某本书或者某个现成的函数库，而是将现有的各种类组合而成，因此，其结果并非同质同种
  * string被设计为安全易用的组件，其接口不言自明，并能对许多可能的错误进行检验
  * STL的设计目标是，将不同的算法和数据结构结合在一起以获得最佳效率，所以，STL并不容易用，也不检验许多可能的逻辑错误

二、新的语言特性

- C++语言核心和C++程序库是同时被标准化的，程序库可以从语言的发展中获益，语言的发展可以从程序库的实践中得到启发
- 如今的C++已经不是五年前的C++了，本节会介绍语言的一些新特性
- 编写本书的时候（1998年），并非所有的编译器都支持所有的语言特性，这限制了程序库的使用，这种情况会很快得到改善

1、模板

- 程序库中的很多东西都被设计为模板的形式，不支持模板就无法使用程序库
- 所谓模板是指针对一个或多个尚未确定的类型编写的函数或类
- 使用模板时，可以显式地或者隐式地将类型作为参数传递
- 模板并非一次编译就生成适合所有类型的代码，而是针对被使用到的类型进行编译，所以，在实际处理模板时，必须提供一个它的实现才能进行调用

1）非类型模板参数

- 类型可以作为模板的参数，非类型也可以作为模板的参数
- 非类型参数是模板类型的一部分，这意味着使用不同的非类型参数的模板属于不同的类型
- 模板可以有缺省参数，就像函数可以有缺省参数一样

2）关键字typename

- 关键字typename被用作类型之前的标识符号
  * 以typename T::SubType* ptr为例，如果没有关键字typename，SubType会被视为T的一个静态成员
  * 这意味着能够取代T的类型必须具有一个内部类型SubType
  * C++的一般规则是，除了使用typename修饰的之外，所有的标识符号都被视为一个值而不是一个类型
- typename还在模板的声明中被用来替代关键字class

3）成员模板

- 类的成员函数也可以是模板函数，但这样的成员函数既不能是虚函数，也不能有缺省参数
- 这个特性通常被用来为模板类中的成员提供自动类型转换

- 模板构造函数是成员模板函数的一种特殊形式，它被用来在复制对象时实现隐式类型转换
- 注意，模板构造函数并不会隐藏掉隐式拷贝构造函数，当类型完全吻合时，隐式拷贝构造函数会被产生并被调用
- 如果默认的拷贝构造函数不能满足要求，别忘了自己实现一个拷贝构造函数
- 另外，嵌套类本身也可以是一个模板类

2、基本类型的显式初始化

- 使用不带参数的默认构造函数可以将基本类型初始化为0
- 这个特性可以保证，在编写模板函数时，任何类型都有一个确切的初始值

3、异常处理

- 通过异常处理，C++可以在不污染函数接口的情况下处理异常
- 当遇到意外时，可以抛出一个异常来停止正常的处理过程，转而开始一个栈展开过程
  * 这个过程就像离开任一函数区段时的return语句一样，该函数区段内的所有局部对象的析构函数都会被调用
  * 直到退出main函数或者被catch语句处理后这个过程才会停止，如果是第一种情况，程序就结束了

- 异常对象其实就是一般类型的对象，可以是int、string等，也可以是类对象
- 异常规格用来指明某个函数可能抛出哪些异常，比如，throw(bad_alloc)，不带参数的throw则表示该函数不抛出异常

4、名字空间

- 名字空间将不同的标识符号集合在一个有名字的作用域内
  * 如果在名字空间内定义标识符号，名字空间就成为唯一可能和全局符号产生冲突的标记符号
  * 在引用名字空间内的标识符号时，必须在前面加上名字空间，中间用::隔开
- 名字空间定义的是逻辑模块，而非物理模块，在UML中，这样的模块被称为“包”
- 如果某个函数的一个或多个参数的类型被定义在该函数所处的名字空间，则不必为该函数额外指定名字空间，这被称为“Koenig Lookup”，也称为“ADL”

- 通过使用using namespace，可以避免使用冗长的名字空间
  * 使用using namespace就打开了名字空间，这意味着名字冲突问题又出现了
  * 如果不确定是否会引起问题，不应该轻易使用using namespace

5、bool类型

- 为了支持布尔值，C++引入了bool类型，同时引入的还有两个常量，true和false
- C++支持布尔值和整数值之间的自动转换

6、关键字explicit

- explicit用来禁止单参数构造函数被自动用于类型转换，包括赋值操作和以赋值操作表示的初始化

7、新的类型转换操作符

- static_cast将一个值以符合逻辑的方式进行类型转换，这可以被看作通过原来的值构建一个临时对象并通过初始化构建新值
- dynamic_cast将多态类型向下转换类型，这是唯一可以在运行时进行检验的类型转换操作，可以用来检验多态对象的真实类型
- const_cast用来设置或去除类型的常量性，也可以去除volatile修饰符，但不能进行除此之外的任何类型转换
- reinterpret_cast的行为由具体的编译器决定，通常会带来不可移植性
- 这些类型转换操作符替代了原来的圆括号，使得转换操作的意图更加明确
- 注意，这些操作符都只接受一个参数，用逗号隔开的多个参数可能被误认为是一个逗号表达式而引起不易察觉的错误

8、常量静态成员的初始化

- 这个特性允许在类声明中直接对整型常量静态成员进行初始化
- 初始化后，该成员就可以被用于类中
- 当然，对类中的常量静态成员进行定义仍然是必须的

9、main函数的定义式

- 根据C++标准规格，main函数只有两种形式是可移植的
  * int main()：不带参数的形式
  * int main(int argc, char* argv[])：带参数的形式
- 这里的argv也可以定义为char**
- 返回类型必须明确指明为整型
- main函数的最后可以没有return语句，此时，编译器会在main函数的最后自动产生一个return 0语句

三、复杂度和Big-O表示法

- 计算机科学家运用特定的符号对算法的复杂度进行定性比较，以便对算法的运行时间加以分类，这种衡量方法称为“Big-O表示法”
- Big-O表示法将一个算法的运行时间用输入量n的函数来表示
  * 当运行时间独立于元素的数量时，复杂度为O(1)
  * 当运行时间随元素的数量呈对数增长时，复杂度为O(log(n))
  * 当运行时间随元素的数量呈线性增长时，复杂度为O(n)
  * 当运行时间随元素的数量呈线性和对数的乘积增长时，复杂度为O(n * log(n))
  * 当运行时间随元素的数量呈平方增长时，复杂度为O(n * n)

- Big-O表示法忽略了指数较小的因子，比如常数因子，这意味着它并不关心算法到底耗费了多长时间，也就是说，两个线性算法会被视为具有相同的复杂度
- 所以，在这种衡量方法下，具有最低复杂度的算法不一定就是最快的算法
- C++标准手册中的某些复杂度被称为“分期摊还”，意思是就长期大量的操作而言具有该复杂度，但单一操作却可能耗费大量的时间，比如，向动态数组添加元素时，如果内存足够，就属于常数复杂度，否则，就必须重新分配足够的内存并复制现有的元素，这就属于线性复杂度

<2022-12-23>
